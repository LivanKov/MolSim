// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "MolSim.hxx"

// boundary_condition_type
// 

boundary_condition_type::
boundary_condition_type (value v)
: ::xml_schema::string (_xsd_boundary_condition_type_literals_[v])
{
}

boundary_condition_type::
boundary_condition_type (const char* v)
: ::xml_schema::string (v)
{
}

boundary_condition_type::
boundary_condition_type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

boundary_condition_type::
boundary_condition_type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

boundary_condition_type::
boundary_condition_type (const boundary_condition_type& v,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

boundary_condition_type& boundary_condition_type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_boundary_condition_type_literals_[v]);

  return *this;
}


// MolSim
// 

const MolSim::simulation_parameters_type& MolSim::
simulation_parameters () const
{
  return this->simulation_parameters_.get ();
}

MolSim::simulation_parameters_type& MolSim::
simulation_parameters ()
{
  return this->simulation_parameters_.get ();
}

void MolSim::
simulation_parameters (const simulation_parameters_type& x)
{
  this->simulation_parameters_.set (x);
}

void MolSim::
simulation_parameters (::std::auto_ptr< simulation_parameters_type > x)
{
  this->simulation_parameters_.set (x);
}

const MolSim::boundary_conditions_optional& MolSim::
boundary_conditions () const
{
  return this->boundary_conditions_;
}

MolSim::boundary_conditions_optional& MolSim::
boundary_conditions ()
{
  return this->boundary_conditions_;
}

void MolSim::
boundary_conditions (const boundary_conditions_type& x)
{
  this->boundary_conditions_.set (x);
}

void MolSim::
boundary_conditions (const boundary_conditions_optional& x)
{
  this->boundary_conditions_ = x;
}

void MolSim::
boundary_conditions (::std::auto_ptr< boundary_conditions_type > x)
{
  this->boundary_conditions_.set (x);
}

const MolSim::discs_optional& MolSim::
discs () const
{
  return this->discs_;
}

MolSim::discs_optional& MolSim::
discs ()
{
  return this->discs_;
}

void MolSim::
discs (const discs_type& x)
{
  this->discs_.set (x);
}

void MolSim::
discs (const discs_optional& x)
{
  this->discs_ = x;
}

void MolSim::
discs (::std::auto_ptr< discs_type > x)
{
  this->discs_.set (x);
}

const MolSim::cuboids_optional& MolSim::
cuboids () const
{
  return this->cuboids_;
}

MolSim::cuboids_optional& MolSim::
cuboids ()
{
  return this->cuboids_;
}

void MolSim::
cuboids (const cuboids_type& x)
{
  this->cuboids_.set (x);
}

void MolSim::
cuboids (const cuboids_optional& x)
{
  this->cuboids_ = x;
}

void MolSim::
cuboids (::std::auto_ptr< cuboids_type > x)
{
  this->cuboids_.set (x);
}


// simulation_parameters
// 

const simulation_parameters::end_time_type& simulation_parameters::
end_time () const
{
  return this->end_time_.get ();
}

simulation_parameters::end_time_type& simulation_parameters::
end_time ()
{
  return this->end_time_.get ();
}

void simulation_parameters::
end_time (const end_time_type& x)
{
  this->end_time_.set (x);
}

const simulation_parameters::delta_time_type& simulation_parameters::
delta_time () const
{
  return this->delta_time_.get ();
}

simulation_parameters::delta_time_type& simulation_parameters::
delta_time ()
{
  return this->delta_time_.get ();
}

void simulation_parameters::
delta_time (const delta_time_type& x)
{
  this->delta_time_.set (x);
}

const simulation_parameters::output_basename_type& simulation_parameters::
output_basename () const
{
  return this->output_basename_.get ();
}

simulation_parameters::output_basename_type& simulation_parameters::
output_basename ()
{
  return this->output_basename_.get ();
}

void simulation_parameters::
output_basename (const output_basename_type& x)
{
  this->output_basename_.set (x);
}

void simulation_parameters::
output_basename (::std::auto_ptr< output_basename_type > x)
{
  this->output_basename_.set (x);
}

const simulation_parameters::write_frequency_type& simulation_parameters::
write_frequency () const
{
  return this->write_frequency_.get ();
}

simulation_parameters::write_frequency_type& simulation_parameters::
write_frequency ()
{
  return this->write_frequency_.get ();
}

void simulation_parameters::
write_frequency (const write_frequency_type& x)
{
  this->write_frequency_.set (x);
}

const simulation_parameters::r_cutoff_radius_type& simulation_parameters::
r_cutoff_radius () const
{
  return this->r_cutoff_radius_.get ();
}

simulation_parameters::r_cutoff_radius_type& simulation_parameters::
r_cutoff_radius ()
{
  return this->r_cutoff_radius_.get ();
}

void simulation_parameters::
r_cutoff_radius (const r_cutoff_radius_type& x)
{
  this->r_cutoff_radius_.set (x);
}

const simulation_parameters::domain_size_type& simulation_parameters::
domain_size () const
{
  return this->domain_size_.get ();
}

simulation_parameters::domain_size_type& simulation_parameters::
domain_size ()
{
  return this->domain_size_.get ();
}

void simulation_parameters::
domain_size (const domain_size_type& x)
{
  this->domain_size_.set (x);
}

void simulation_parameters::
domain_size (::std::auto_ptr< domain_size_type > x)
{
  this->domain_size_.set (x);
}



// boundary_conditions
// 

const boundary_conditions::left_type& boundary_conditions::
left () const
{
  return this->left_.get ();
}

boundary_conditions::left_type& boundary_conditions::
left ()
{
  return this->left_.get ();
}

void boundary_conditions::
left (const left_type& x)
{
  this->left_.set (x);
}

void boundary_conditions::
left (::std::auto_ptr< left_type > x)
{
  this->left_.set (x);
}

const boundary_conditions::right_type& boundary_conditions::
right () const
{
  return this->right_.get ();
}

boundary_conditions::right_type& boundary_conditions::
right ()
{
  return this->right_.get ();
}

void boundary_conditions::
right (const right_type& x)
{
  this->right_.set (x);
}

void boundary_conditions::
right (::std::auto_ptr< right_type > x)
{
  this->right_.set (x);
}

const boundary_conditions::top_type& boundary_conditions::
top () const
{
  return this->top_.get ();
}

boundary_conditions::top_type& boundary_conditions::
top ()
{
  return this->top_.get ();
}

void boundary_conditions::
top (const top_type& x)
{
  this->top_.set (x);
}

void boundary_conditions::
top (::std::auto_ptr< top_type > x)
{
  this->top_.set (x);
}

const boundary_conditions::bottom_type& boundary_conditions::
bottom () const
{
  return this->bottom_.get ();
}

boundary_conditions::bottom_type& boundary_conditions::
bottom ()
{
  return this->bottom_.get ();
}

void boundary_conditions::
bottom (const bottom_type& x)
{
  this->bottom_.set (x);
}

void boundary_conditions::
bottom (::std::auto_ptr< bottom_type > x)
{
  this->bottom_.set (x);
}

const boundary_conditions::front_optional& boundary_conditions::
front () const
{
  return this->front_;
}

boundary_conditions::front_optional& boundary_conditions::
front ()
{
  return this->front_;
}

void boundary_conditions::
front (const front_type& x)
{
  this->front_.set (x);
}

void boundary_conditions::
front (const front_optional& x)
{
  this->front_ = x;
}

void boundary_conditions::
front (::std::auto_ptr< front_type > x)
{
  this->front_.set (x);
}

const boundary_conditions::back_optional& boundary_conditions::
back () const
{
  return this->back_;
}

boundary_conditions::back_optional& boundary_conditions::
back ()
{
  return this->back_;
}

void boundary_conditions::
back (const back_type& x)
{
  this->back_.set (x);
}

void boundary_conditions::
back (const back_optional& x)
{
  this->back_ = x;
}

void boundary_conditions::
back (::std::auto_ptr< back_type > x)
{
  this->back_.set (x);
}

// discs
// 

const discs::disc_sequence& discs::
disc () const
{
  return this->disc_;
}

discs::disc_sequence& discs::
disc ()
{
  return this->disc_;
}

void discs::
disc (const disc_sequence& s)
{
  this->disc_ = s;
}


// cuboids
// 

const cuboids::cuboid_sequence& cuboids::
cuboid () const
{
  return this->cuboid_;
}

cuboids::cuboid_sequence& cuboids::
cuboid ()
{
  return this->cuboid_;
}

void cuboids::
cuboid (const cuboid_sequence& s)
{
  this->cuboid_ = s;
}


// domain_size
// 

const domain_size::x_type& domain_size::
x () const
{
  return this->x_.get ();
}

domain_size::x_type& domain_size::
x ()
{
  return this->x_.get ();
}

void domain_size::
x (const x_type& x)
{
  this->x_.set (x);
}

const domain_size::y_type& domain_size::
y () const
{
  return this->y_.get ();
}

domain_size::y_type& domain_size::
y ()
{
  return this->y_.get ();
}

void domain_size::
y (const y_type& x)
{
  this->y_.set (x);
}

const domain_size::z_type& domain_size::
z () const
{
  return this->z_.get ();
}

domain_size::z_type& domain_size::
z ()
{
  return this->z_.get ();
}

void domain_size::
z (const z_type& x)
{
  this->z_.set (x);
}


// disc
// 

const disc::center_type& disc::
center () const
{
  return this->center_.get ();
}

disc::center_type& disc::
center ()
{
  return this->center_.get ();
}

void disc::
center (const center_type& x)
{
  this->center_.set (x);
}

void disc::
center (::std::auto_ptr< center_type > x)
{
  this->center_.set (x);
}

const disc::initial_velocity_type& disc::
initial_velocity () const
{
  return this->initial_velocity_.get ();
}

disc::initial_velocity_type& disc::
initial_velocity ()
{
  return this->initial_velocity_.get ();
}

void disc::
initial_velocity (const initial_velocity_type& x)
{
  this->initial_velocity_.set (x);
}

void disc::
initial_velocity (::std::auto_ptr< initial_velocity_type > x)
{
  this->initial_velocity_.set (x);
}

const disc::radius_type& disc::
radius () const
{
  return this->radius_.get ();
}

disc::radius_type& disc::
radius ()
{
  return this->radius_.get ();
}

void disc::
radius (const radius_type& x)
{
  this->radius_.set (x);
}

const disc::mesh_width_type& disc::
mesh_width () const
{
  return this->mesh_width_.get ();
}

disc::mesh_width_type& disc::
mesh_width ()
{
  return this->mesh_width_.get ();
}

void disc::
mesh_width (const mesh_width_type& x)
{
  this->mesh_width_.set (x);
}

const disc::mass_type& disc::
mass () const
{
  return this->mass_.get ();
}

disc::mass_type& disc::
mass ()
{
  return this->mass_.get ();
}

void disc::
mass (const mass_type& x)
{
  this->mass_.set (x);
}


// cuboid
// 

const cuboid::coordinate_type& cuboid::
coordinate () const
{
  return this->coordinate_.get ();
}

cuboid::coordinate_type& cuboid::
coordinate ()
{
  return this->coordinate_.get ();
}

void cuboid::
coordinate (const coordinate_type& x)
{
  this->coordinate_.set (x);
}

void cuboid::
coordinate (::std::auto_ptr< coordinate_type > x)
{
  this->coordinate_.set (x);
}

const cuboid::dimensions_type& cuboid::
dimensions () const
{
  return this->dimensions_.get ();
}

cuboid::dimensions_type& cuboid::
dimensions ()
{
  return this->dimensions_.get ();
}

void cuboid::
dimensions (const dimensions_type& x)
{
  this->dimensions_.set (x);
}

void cuboid::
dimensions (::std::auto_ptr< dimensions_type > x)
{
  this->dimensions_.set (x);
}

const cuboid::mesh_width_type& cuboid::
mesh_width () const
{
  return this->mesh_width_.get ();
}

cuboid::mesh_width_type& cuboid::
mesh_width ()
{
  return this->mesh_width_.get ();
}

void cuboid::
mesh_width (const mesh_width_type& x)
{
  this->mesh_width_.set (x);
}

const cuboid::mass_type& cuboid::
mass () const
{
  return this->mass_.get ();
}

cuboid::mass_type& cuboid::
mass ()
{
  return this->mass_.get ();
}

void cuboid::
mass (const mass_type& x)
{
  this->mass_.set (x);
}

const cuboid::initial_velocity_type& cuboid::
initial_velocity () const
{
  return this->initial_velocity_.get ();
}

cuboid::initial_velocity_type& cuboid::
initial_velocity ()
{
  return this->initial_velocity_.get ();
}

void cuboid::
initial_velocity (const initial_velocity_type& x)
{
  this->initial_velocity_.set (x);
}

void cuboid::
initial_velocity (::std::auto_ptr< initial_velocity_type > x)
{
  this->initial_velocity_.set (x);
}

const cuboid::average_velocity_type& cuboid::
average_velocity () const
{
  return this->average_velocity_.get ();
}

cuboid::average_velocity_type& cuboid::
average_velocity ()
{
  return this->average_velocity_.get ();
}

void cuboid::
average_velocity (const average_velocity_type& x)
{
  this->average_velocity_.set (x);
}


// center
// 

const center::x_type& center::
x () const
{
  return this->x_.get ();
}

center::x_type& center::
x ()
{
  return this->x_.get ();
}

void center::
x (const x_type& x)
{
  this->x_.set (x);
}

const center::y_type& center::
y () const
{
  return this->y_.get ();
}

center::y_type& center::
y ()
{
  return this->y_.get ();
}

void center::
y (const y_type& x)
{
  this->y_.set (x);
}

const center::z_type& center::
z () const
{
  return this->z_.get ();
}

center::z_type& center::
z ()
{
  return this->z_.get ();
}

void center::
z (const z_type& x)
{
  this->z_.set (x);
}


// initial_velocity
// 

const initial_velocity::x_type& initial_velocity::
x () const
{
  return this->x_.get ();
}

initial_velocity::x_type& initial_velocity::
x ()
{
  return this->x_.get ();
}

void initial_velocity::
x (const x_type& x)
{
  this->x_.set (x);
}

const initial_velocity::y_type& initial_velocity::
y () const
{
  return this->y_.get ();
}

initial_velocity::y_type& initial_velocity::
y ()
{
  return this->y_.get ();
}

void initial_velocity::
y (const y_type& x)
{
  this->y_.set (x);
}

const initial_velocity::z_type& initial_velocity::
z () const
{
  return this->z_.get ();
}

initial_velocity::z_type& initial_velocity::
z ()
{
  return this->z_.get ();
}

void initial_velocity::
z (const z_type& x)
{
  this->z_.set (x);
}


// coordinate
// 

const coordinate::x_type& coordinate::
x () const
{
  return this->x_.get ();
}

coordinate::x_type& coordinate::
x ()
{
  return this->x_.get ();
}

void coordinate::
x (const x_type& x)
{
  this->x_.set (x);
}

const coordinate::y_type& coordinate::
y () const
{
  return this->y_.get ();
}

coordinate::y_type& coordinate::
y ()
{
  return this->y_.get ();
}

void coordinate::
y (const y_type& x)
{
  this->y_.set (x);
}

const coordinate::z_type& coordinate::
z () const
{
  return this->z_.get ();
}

coordinate::z_type& coordinate::
z ()
{
  return this->z_.get ();
}

void coordinate::
z (const z_type& x)
{
  this->z_.set (x);
}


// dimensions
// 

const dimensions::x_type& dimensions::
x () const
{
  return this->x_.get ();
}

dimensions::x_type& dimensions::
x ()
{
  return this->x_.get ();
}

void dimensions::
x (const x_type& x)
{
  this->x_.set (x);
}

const dimensions::y_type& dimensions::
y () const
{
  return this->y_.get ();
}

dimensions::y_type& dimensions::
y ()
{
  return this->y_.get ();
}

void dimensions::
y (const y_type& x)
{
  this->y_.set (x);
}

const dimensions::z_type& dimensions::
z () const
{
  return this->z_.get ();
}

dimensions::z_type& dimensions::
z ()
{
  return this->z_.get ();
}

void dimensions::
z (const z_type& x)
{
  this->z_.set (x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// boundary_condition_type
//

boundary_condition_type::
boundary_condition_type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_boundary_condition_type_convert ();
}

boundary_condition_type::
boundary_condition_type (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_boundary_condition_type_convert ();
}

boundary_condition_type::
boundary_condition_type (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_boundary_condition_type_convert ();
}

boundary_condition_type* boundary_condition_type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class boundary_condition_type (*this, f, c);
}

boundary_condition_type::value boundary_condition_type::
_xsd_boundary_condition_type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_boundary_condition_type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_boundary_condition_type_indexes_,
                    _xsd_boundary_condition_type_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_boundary_condition_type_indexes_ + 2 || _xsd_boundary_condition_type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const boundary_condition_type::
_xsd_boundary_condition_type_literals_[2] =
{
  "Outflow",
  "Reflecting"
};

const boundary_condition_type::value boundary_condition_type::
_xsd_boundary_condition_type_indexes_[2] =
{
  ::boundary_condition_type::Outflow,
  ::boundary_condition_type::Reflecting
};

// MolSim
//

MolSim::
MolSim (const simulation_parameters_type& simulation_parameters)
: ::xml_schema::type (),
  simulation_parameters_ (simulation_parameters, this),
  boundary_conditions_ (this),
  discs_ (this),
  cuboids_ (this)
{
}

MolSim::
MolSim (::std::auto_ptr< simulation_parameters_type > simulation_parameters)
: ::xml_schema::type (),
  simulation_parameters_ (simulation_parameters, this),
  boundary_conditions_ (this),
  discs_ (this),
  cuboids_ (this)
{
}

MolSim::
MolSim (const MolSim& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  simulation_parameters_ (x.simulation_parameters_, f, this),
  boundary_conditions_ (x.boundary_conditions_, f, this),
  discs_ (x.discs_, f, this),
  cuboids_ (x.cuboids_, f, this)
{
}

MolSim::
MolSim (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  simulation_parameters_ (this),
  boundary_conditions_ (this),
  discs_ (this),
  cuboids_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void MolSim::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // simulation_parameters
    //
    if (n.name () == "simulation_parameters" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< simulation_parameters_type > r (
        simulation_parameters_traits::create (i, f, this));

      if (!simulation_parameters_.present ())
      {
        this->simulation_parameters_.set (r);
        continue;
      }
    }


    // boundary_conditions
    //
    if (n.name () == "boundary_conditions" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< boundary_conditions_type > r (
        boundary_conditions_traits::create (i, f, this));

      if (!this->boundary_conditions_)
      {
        this->boundary_conditions_.set (r);
        continue;
      }
    }
    // discs
    //
    if (n.name () == "discs" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< discs_type > r (
        discs_traits::create (i, f, this));

      if (!this->discs_)
      {
        this->discs_.set (r);
        continue;
      }
    }

    // cuboids
    //
    if (n.name () == "cuboids" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< cuboids_type > r (
        cuboids_traits::create (i, f, this));

      if (!this->cuboids_)
      {
        this->cuboids_.set (r);
        continue;
      }
    }

    break;
  }

  if (!simulation_parameters_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "simulation_parameters",
      "");
  }
}

MolSim* MolSim::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MolSim (*this, f, c);
}

MolSim& MolSim::
operator= (const MolSim& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->simulation_parameters_ = x.simulation_parameters_;
    this->boundary_conditions_ = x.boundary_conditions_;
    this->discs_ = x.discs_;
    this->cuboids_ = x.cuboids_;
  }

  return *this;
}

MolSim::
~MolSim ()
{
}

// simulation_parameters
//

simulation_parameters::
simulation_parameters (const end_time_type& end_time,
                       const delta_time_type& delta_time,
                       const output_basename_type& output_basename,
                       const write_frequency_type& write_frequency,
                       const r_cutoff_radius_type& r_cutoff_radius,
                       const domain_size_type& domain_size)
: ::xml_schema::type (),
  end_time_ (end_time, this),
  delta_time_ (delta_time, this),
  output_basename_ (output_basename, this),
  write_frequency_ (write_frequency, this),
  r_cutoff_radius_ (r_cutoff_radius, this),
  domain_size_ (domain_size, this)
{
}

simulation_parameters::
simulation_parameters (const end_time_type& end_time,
                       const delta_time_type& delta_time,
                       const output_basename_type& output_basename,
                       const write_frequency_type& write_frequency,
                       const r_cutoff_radius_type& r_cutoff_radius,
                       ::std::auto_ptr< domain_size_type > domain_size)
: ::xml_schema::type (),
  end_time_ (end_time, this),
  delta_time_ (delta_time, this),
  output_basename_ (output_basename, this),
  write_frequency_ (write_frequency, this),
  r_cutoff_radius_ (r_cutoff_radius, this),
  domain_size_ (domain_size, this)
{
}

simulation_parameters::
simulation_parameters (const simulation_parameters& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  end_time_ (x.end_time_, f, this),
  delta_time_ (x.delta_time_, f, this),
  output_basename_ (x.output_basename_, f, this),
  write_frequency_ (x.write_frequency_, f, this),
  r_cutoff_radius_ (x.r_cutoff_radius_, f, this),
  domain_size_ (x.domain_size_, f, this)
{
}

simulation_parameters::
simulation_parameters (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  end_time_ (this),
  delta_time_ (this),
  output_basename_ (this),
  write_frequency_ (this),
  r_cutoff_radius_ (this),
  domain_size_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void simulation_parameters::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // end_time
    //
    if (n.name () == "end_time" && n.namespace_ ().empty ())
    {
      if (!end_time_.present ())
      {
        this->end_time_.set (end_time_traits::create (i, f, this));
        continue;
      }
    }

    // delta_time
    //
    if (n.name () == "delta_time" && n.namespace_ ().empty ())
    {
      if (!delta_time_.present ())
      {
        this->delta_time_.set (delta_time_traits::create (i, f, this));
        continue;
      }
    }

    // output_basename
    //
    if (n.name () == "output_basename" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< output_basename_type > r (
        output_basename_traits::create (i, f, this));

      if (!output_basename_.present ())
      {
        this->output_basename_.set (r);
        continue;
      }
    }

    // write_frequency
    //
    if (n.name () == "write_frequency" && n.namespace_ ().empty ())
    {
      if (!write_frequency_.present ())
      {
        this->write_frequency_.set (write_frequency_traits::create (i, f, this));
        continue;
      }
    }

    // r_cutoff_radius
    //
    if (n.name () == "r_cutoff_radius" && n.namespace_ ().empty ())
    {
      if (!r_cutoff_radius_.present ())
      {
        this->r_cutoff_radius_.set (r_cutoff_radius_traits::create (i, f, this));
        continue;
      }
    }

    // domain_size
    //
    if (n.name () == "domain_size" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< domain_size_type > r (
        domain_size_traits::create (i, f, this));

      if (!domain_size_.present ())
      {
        this->domain_size_.set (r);
        continue;
      }
    }

    break;
  }

  if (!end_time_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "end_time",
      "");
  }

  if (!delta_time_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "delta_time",
      "");
  }

  if (!output_basename_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "output_basename",
      "");
  }

  if (!write_frequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "write_frequency",
      "");
  }

  if (!r_cutoff_radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "r_cutoff_radius",
      "");
  }

  if (!domain_size_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "domain_size",
      "");
  }
}

simulation_parameters* simulation_parameters::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class simulation_parameters (*this, f, c);
}

simulation_parameters& simulation_parameters::
operator= (const simulation_parameters& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->end_time_ = x.end_time_;
    this->delta_time_ = x.delta_time_;
    this->output_basename_ = x.output_basename_;
    this->write_frequency_ = x.write_frequency_;
    this->r_cutoff_radius_ = x.r_cutoff_radius_;
    this->domain_size_ = x.domain_size_;
  }

  return *this;
}

simulation_parameters::
~simulation_parameters ()
{
}

// discs
// boundary_conditions
//

boundary_conditions::
boundary_conditions (const left_type& left,
                     const right_type& right,
                     const top_type& top,
                     const bottom_type& bottom)
: ::xml_schema::type (),
  left_ (left, this),
  right_ (right, this),
  top_ (top, this),
  bottom_ (bottom, this),
  front_ (this),
  back_ (this)
{
}

boundary_conditions::
boundary_conditions (const boundary_conditions& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  left_ (x.left_, f, this),
  right_ (x.right_, f, this),
  top_ (x.top_, f, this),
  bottom_ (x.bottom_, f, this),
  front_ (x.front_, f, this),
  back_ (x.back_, f, this)
{
}

boundary_conditions::
boundary_conditions (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  left_ (this),
  right_ (this),
  top_ (this),
  bottom_ (this),
  front_ (this),
  back_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void boundary_conditions::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // left
    //
    if (n.name () == "left" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< left_type > r (
        left_traits::create (i, f, this));

      if (!left_.present ())
      {
        this->left_.set (r);
        continue;
      }
    }

    // right
    //
    if (n.name () == "right" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< right_type > r (
        right_traits::create (i, f, this));

      if (!right_.present ())
      {
        this->right_.set (r);
        continue;
      }
    }

    // top
    //
    if (n.name () == "top" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< top_type > r (
        top_traits::create (i, f, this));

      if (!top_.present ())
      {
        this->top_.set (r);
        continue;
      }
    }

    // bottom
    //
    if (n.name () == "bottom" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< bottom_type > r (
        bottom_traits::create (i, f, this));

      if (!bottom_.present ())
      {
        this->bottom_.set (r);
        continue;
      }
    }

    // front
    //
    if (n.name () == "front" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< front_type > r (
        front_traits::create (i, f, this));

      if (!this->front_)
      {
        this->front_.set (r);
        continue;
      }
    }

    // back
    //
    if (n.name () == "back" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< back_type > r (
        back_traits::create (i, f, this));

      if (!this->back_)
      {
        this->back_.set (r);
        continue;
      }
    }

    break;
  }

  if (!left_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "left",
      "");
  }

  if (!right_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "right",
      "");
  }

  if (!top_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "top",
      "");
  }

  if (!bottom_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "bottom",
      "");
  }
}

boundary_conditions* boundary_conditions::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class boundary_conditions (*this, f, c);
}

boundary_conditions& boundary_conditions::
operator= (const boundary_conditions& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->left_ = x.left_;
    this->right_ = x.right_;
    this->top_ = x.top_;
    this->bottom_ = x.bottom_;
    this->front_ = x.front_;
    this->back_ = x.back_;
  }

  return *this;
}

boundary_conditions::
~boundary_conditions ()
{
}

// discs
//

discs::
discs ()
: ::xml_schema::type (),
  disc_ (this)
{
}

discs::
discs (const discs& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  disc_ (x.disc_, f, this)
{
}

discs::
discs (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  disc_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void discs::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // disc
    //
    if (n.name () == "disc" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< disc_type > r (
        disc_traits::create (i, f, this));

      this->disc_.push_back (r);
      continue;
    }

    break;
  }
}

discs* discs::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class discs (*this, f, c);
}

discs& discs::
operator= (const discs& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->disc_ = x.disc_;
  }

  return *this;
}

discs::
~discs ()
{
}

// cuboids
//

cuboids::
cuboids ()
: ::xml_schema::type (),
  cuboid_ (this)
{
}

cuboids::
cuboids (const cuboids& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  cuboid_ (x.cuboid_, f, this)
{
}

cuboids::
cuboids (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  cuboid_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void cuboids::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // cuboid
    //
    if (n.name () == "cuboid" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< cuboid_type > r (
        cuboid_traits::create (i, f, this));

      this->cuboid_.push_back (r);
      continue;
    }

    break;
  }
}

cuboids* cuboids::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class cuboids (*this, f, c);
}

cuboids& cuboids::
operator= (const cuboids& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->cuboid_ = x.cuboid_;
  }

  return *this;
}

cuboids::
~cuboids ()
{
}

// domain_size
//

domain_size::
domain_size (const x_type& x,
             const y_type& y,
             const z_type& z)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (z, this)
{
}

domain_size::
domain_size (const domain_size& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

domain_size::
domain_size (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void domain_size::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // x
    //
    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      if (!x_.present ())
      {
        this->x_.set (x_traits::create (i, f, this));
        continue;
      }
    }

    // y
    //
    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      if (!y_.present ())
      {
        this->y_.set (y_traits::create (i, f, this));
        continue;
      }
    }

    // z
    //
    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      if (!z_.present ())
      {
        this->z_.set (z_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "y",
      "");
  }

  if (!z_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "z",
      "");
  }
}

domain_size* domain_size::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class domain_size (*this, f, c);
}

domain_size& domain_size::
operator= (const domain_size& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

domain_size::
~domain_size ()
{
}

// disc
//

disc::
disc (const center_type& center,
      const initial_velocity_type& initial_velocity,
      const radius_type& radius,
      const mesh_width_type& mesh_width,
      const mass_type& mass)
: ::xml_schema::type (),
  center_ (center, this),
  initial_velocity_ (initial_velocity, this),
  radius_ (radius, this),
  mesh_width_ (mesh_width, this),
  mass_ (mass, this)
{
}

// disc
//


disc::
disc (::std::auto_ptr< center_type > center,
      ::std::auto_ptr< initial_velocity_type > initial_velocity,
      const radius_type& radius,
      const mesh_width_type& mesh_width,
      const mass_type& mass)
: ::xml_schema::type (),
  center_ (center, this),
  initial_velocity_ (initial_velocity, this),
  radius_ (radius, this),
  mesh_width_ (mesh_width, this),
  mass_ (mass, this)
{
}

disc::
disc (const disc& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  center_ (x.center_, f, this),
  initial_velocity_ (x.initial_velocity_, f, this),
  radius_ (x.radius_, f, this),
  mesh_width_ (x.mesh_width_, f, this),
  mass_ (x.mass_, f, this)
{
}

disc::
disc (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  center_ (this),
  initial_velocity_ (this),
  radius_ (this),
  mesh_width_ (this),
  mass_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void disc::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // center
    //
    if (n.name () == "center" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< center_type > r (
        center_traits::create (i, f, this));

      if (!center_.present ())
      {
        this->center_.set (r);
        continue;
      }
    }

    // initial_velocity
    //
    if (n.name () == "initial_velocity" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< initial_velocity_type > r (
        initial_velocity_traits::create (i, f, this));

      if (!initial_velocity_.present ())
      {
        this->initial_velocity_.set (r);
        continue;
      }
    }

    // radius
    //
    if (n.name () == "radius" && n.namespace_ ().empty ())
    {
      if (!radius_.present ())
      {
        this->radius_.set (radius_traits::create (i, f, this));
        continue;
      }
    }

    // mesh_width
    //
    if (n.name () == "mesh_width" && n.namespace_ ().empty ())
    {
      if (!mesh_width_.present ())
      {
        this->mesh_width_.set (mesh_width_traits::create (i, f, this));
        continue;
      }
    }

    // mass
    //
    if (n.name () == "mass" && n.namespace_ ().empty ())
    {
      if (!mass_.present ())
      {
        this->mass_.set (mass_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!center_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "center",
      "");
  }

  if (!initial_velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "initial_velocity",
      "");
  }

  if (!radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "radius",
      "");
  }

  if (!mesh_width_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mesh_width",
      "");
  }

  if (!mass_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mass",
      "");
  }
}

disc* disc::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class disc (*this, f, c);
}

disc& disc::
operator= (const disc& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->center_ = x.center_;
    this->initial_velocity_ = x.initial_velocity_;
    this->radius_ = x.radius_;
    this->mesh_width_ = x.mesh_width_;
    this->mass_ = x.mass_;
  }

  return *this;
}

disc::
~disc ()
{
}

// cuboid
//

cuboid::
cuboid (const coordinate_type& coordinate,
        const dimensions_type& dimensions,
        const mesh_width_type& mesh_width,
        const mass_type& mass,
        const initial_velocity_type& initial_velocity,
        const average_velocity_type& average_velocity)
: ::xml_schema::type (),
  coordinate_ (coordinate, this),
  dimensions_ (dimensions, this),
  mesh_width_ (mesh_width, this),
  mass_ (mass, this),
  initial_velocity_ (initial_velocity, this),
  average_velocity_ (average_velocity, this)
{
}

cuboid::
cuboid (::std::auto_ptr< coordinate_type > coordinate,
        ::std::auto_ptr< dimensions_type > dimensions,
        const mesh_width_type& mesh_width,
        const mass_type& mass,
        ::std::auto_ptr< initial_velocity_type > initial_velocity,
        const average_velocity_type& average_velocity)
: ::xml_schema::type (),
  coordinate_ (coordinate, this),
  dimensions_ (dimensions, this),
  mesh_width_ (mesh_width, this),
  mass_ (mass, this),
  initial_velocity_ (initial_velocity, this),
  average_velocity_ (average_velocity, this)
{
}

cuboid::
cuboid (const cuboid& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  coordinate_ (x.coordinate_, f, this),
  dimensions_ (x.dimensions_, f, this),
  mesh_width_ (x.mesh_width_, f, this),
  mass_ (x.mass_, f, this),
  initial_velocity_ (x.initial_velocity_, f, this),
  average_velocity_ (x.average_velocity_, f, this)
{
}

cuboid::
cuboid (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  coordinate_ (this),
  dimensions_ (this),
  mesh_width_ (this),
  mass_ (this),
  initial_velocity_ (this),
  average_velocity_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void cuboid::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // coordinate
    //
    if (n.name () == "coordinate" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< coordinate_type > r (
        coordinate_traits::create (i, f, this));

      if (!coordinate_.present ())
      {
        this->coordinate_.set (r);
        continue;
      }
    }

    // dimensions
    //
    if (n.name () == "dimensions" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dimensions_type > r (
        dimensions_traits::create (i, f, this));

      if (!dimensions_.present ())
      {
        this->dimensions_.set (r);
        continue;
      }
    }

    // mesh_width
    //
    if (n.name () == "mesh_width" && n.namespace_ ().empty ())
    {
      if (!mesh_width_.present ())
      {
        this->mesh_width_.set (mesh_width_traits::create (i, f, this));
        continue;
      }
    }

    // mass
    //
    if (n.name () == "mass" && n.namespace_ ().empty ())
    {
      if (!mass_.present ())
      {
        this->mass_.set (mass_traits::create (i, f, this));
        continue;
      }
    }

    // initial_velocity
    //
    if (n.name () == "initial_velocity" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< initial_velocity_type > r (
        initial_velocity_traits::create (i, f, this));

      if (!initial_velocity_.present ())
      {
        this->initial_velocity_.set (r);
        continue;
      }
    }

    // average_velocity
    //
    if (n.name () == "average_velocity" && n.namespace_ ().empty ())
    {
      if (!average_velocity_.present ())
      {
        this->average_velocity_.set (average_velocity_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!coordinate_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "coordinate",
      "");
  }

  if (!dimensions_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "dimensions",
      "");
  }

  if (!mesh_width_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mesh_width",
      "");
  }

  if (!mass_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mass",
      "");
  }

  if (!initial_velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "initial_velocity",
      "");
  }

  if (!average_velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "average_velocity",
      "");
  }
}

cuboid* cuboid::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class cuboid (*this, f, c);
}

cuboid& cuboid::
operator= (const cuboid& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->coordinate_ = x.coordinate_;
    this->dimensions_ = x.dimensions_;
    this->mesh_width_ = x.mesh_width_;
    this->mass_ = x.mass_;
    this->initial_velocity_ = x.initial_velocity_;
    this->average_velocity_ = x.average_velocity_;
  }

  return *this;
}

cuboid::
~cuboid ()
{
}

// center
//

center::
center (const x_type& x,
        const y_type& y,
        const z_type& z)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (z, this)
{
}

center::
center (const center& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

center::
center (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void center::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // x
    //
    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      if (!x_.present ())
      {
        this->x_.set (x_traits::create (i, f, this));
        continue;
      }
    }

    // y
    //
    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      if (!y_.present ())
      {
        this->y_.set (y_traits::create (i, f, this));
        continue;
      }
    }

    // z
    //
    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      if (!z_.present ())
      {
        this->z_.set (z_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "y",
      "");
  }

  if (!z_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "z",
      "");
  }
}

center* center::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class center (*this, f, c);
}

center& center::
operator= (const center& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

center::
~center ()
{
}

// initial_velocity
//

initial_velocity::
initial_velocity (const x_type& x,
                  const y_type& y,
                  const z_type& z)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (z, this)
{
}

initial_velocity::
initial_velocity (const initial_velocity& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

initial_velocity::
initial_velocity (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void initial_velocity::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // x
    //
    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      if (!x_.present ())
      {
        this->x_.set (x_traits::create (i, f, this));
        continue;
      }
    }

    // y
    //
    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      if (!y_.present ())
      {
        this->y_.set (y_traits::create (i, f, this));
        continue;
      }
    }

    // z
    //
    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      if (!z_.present ())
      {
        this->z_.set (z_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "y",
      "");
  }

  if (!z_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "z",
      "");
  }
}

initial_velocity* initial_velocity::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class initial_velocity (*this, f, c);
}

initial_velocity& initial_velocity::
operator= (const initial_velocity& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

initial_velocity::
~initial_velocity ()
{
}

// coordinate
//

coordinate::
coordinate (const x_type& x,
            const y_type& y,
            const z_type& z)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (z, this)
{
}

coordinate::
coordinate (const coordinate& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

coordinate::
coordinate (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void coordinate::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // x
    //
    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      if (!x_.present ())
      {
        this->x_.set (x_traits::create (i, f, this));
        continue;
      }
    }

    // y
    //
    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      if (!y_.present ())
      {
        this->y_.set (y_traits::create (i, f, this));
        continue;
      }
    }

    // z
    //
    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      if (!z_.present ())
      {
        this->z_.set (z_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "y",
      "");
  }

  if (!z_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "z",
      "");
  }
}

coordinate* coordinate::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class coordinate (*this, f, c);
}

coordinate& coordinate::
operator= (const coordinate& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

coordinate::
~coordinate ()
{
}

// dimensions
//

dimensions::
dimensions (const x_type& x,
            const y_type& y,
            const z_type& z)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (z, this)
{
}

dimensions::
dimensions (const dimensions& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

dimensions::
dimensions (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void dimensions::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // x
    //
    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      if (!x_.present ())
      {
        this->x_.set (x_traits::create (i, f, this));
        continue;
      }
    }

    // y
    //
    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      if (!y_.present ())
      {
        this->y_.set (y_traits::create (i, f, this));
        continue;
      }
    }

    // z
    //
    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      if (!z_.present ())
      {
        this->z_.set (z_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "y",
      "");
  }

  if (!z_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "z",
      "");
  }
}

dimensions* dimensions::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class dimensions (*this, f, c);
}

dimensions& dimensions::
operator= (const dimensions& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

dimensions::
~dimensions ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::MolSim >
MolSim_ (const ::std::string& u,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::MolSim > (
    ::MolSim_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::MolSim >
MolSim_ (const ::std::string& u,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::MolSim > (
    ::MolSim_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::MolSim >
MolSim_ (const ::std::string& u,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::MolSim > (
    ::MolSim_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::MolSim >
MolSim_ (::std::istream& is,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::MolSim_ (isrc, f, p);
}

::std::auto_ptr< ::MolSim >
MolSim_ (::std::istream& is,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::MolSim_ (isrc, h, f, p);
}

::std::auto_ptr< ::MolSim >
MolSim_ (::std::istream& is,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::MolSim_ (isrc, h, f, p);
}

::std::auto_ptr< ::MolSim >
MolSim_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::MolSim_ (isrc, f, p);
}

::std::auto_ptr< ::MolSim >
MolSim_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::MolSim_ (isrc, h, f, p);
}

::std::auto_ptr< ::MolSim >
MolSim_ (::std::istream& is,
         const ::std::string& sid,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::MolSim_ (isrc, h, f, p);
}

::std::auto_ptr< ::MolSim >
MolSim_ (::xercesc::InputSource& i,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::MolSim > (
    ::MolSim_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::MolSim >
MolSim_ (::xercesc::InputSource& i,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::MolSim > (
    ::MolSim_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::MolSim >
MolSim_ (::xercesc::InputSource& i,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::MolSim > (
    ::MolSim_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::MolSim >
MolSim_ (const ::xercesc::DOMDocument& doc,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::MolSim > (
      ::MolSim_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "MolSim" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::MolSim > r (
      ::xsd::cxx::tree::traits< ::MolSim, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "MolSim",
    "");
}

::std::auto_ptr< ::MolSim >
MolSim_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
         ::xml_schema::flags f,
         const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "MolSim" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::MolSim > r (
      ::xsd::cxx::tree::traits< ::MolSim, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "MolSim",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

