// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "MolSim.hxx"

// MolSim
// 

const MolSim::simulation_parameters_type& MolSim::
simulation_parameters () const
{
  return this->simulation_parameters_.get ();
}

MolSim::simulation_parameters_type& MolSim::
simulation_parameters ()
{
  return this->simulation_parameters_.get ();
}

void MolSim::
simulation_parameters (const simulation_parameters_type& x)
{
  this->simulation_parameters_.set (x);
}

void MolSim::
simulation_parameters (::std::auto_ptr< simulation_parameters_type > x)
{
  this->simulation_parameters_.set (x);
}

const MolSim::cuboids_type& MolSim::
cuboids () const
{
  return this->cuboids_.get ();
}

MolSim::cuboids_type& MolSim::
cuboids ()
{
  return this->cuboids_.get ();
}

void MolSim::
cuboids (const cuboids_type& x)
{
  this->cuboids_.set (x);
}

void MolSim::
cuboids (::std::auto_ptr< cuboids_type > x)
{
  this->cuboids_.set (x);
}


// simulation_parameters
// 

const simulation_parameters::end_time_type& simulation_parameters::
end_time () const
{
  return this->end_time_.get ();
}

simulation_parameters::end_time_type& simulation_parameters::
end_time ()
{
  return this->end_time_.get ();
}

void simulation_parameters::
end_time (const end_time_type& x)
{
  this->end_time_.set (x);
}

const simulation_parameters::delta_time_type& simulation_parameters::
delta_time () const
{
  return this->delta_time_.get ();
}

simulation_parameters::delta_time_type& simulation_parameters::
delta_time ()
{
  return this->delta_time_.get ();
}

void simulation_parameters::
delta_time (const delta_time_type& x)
{
  this->delta_time_.set (x);
}

const simulation_parameters::output_basename_type& simulation_parameters::
output_basename () const
{
  return this->output_basename_.get ();
}

simulation_parameters::output_basename_type& simulation_parameters::
output_basename ()
{
  return this->output_basename_.get ();
}

void simulation_parameters::
output_basename (const output_basename_type& x)
{
  this->output_basename_.set (x);
}

void simulation_parameters::
output_basename (::std::auto_ptr< output_basename_type > x)
{
  this->output_basename_.set (x);
}

const simulation_parameters::write_frequency_type& simulation_parameters::
write_frequency () const
{
  return this->write_frequency_.get ();
}

simulation_parameters::write_frequency_type& simulation_parameters::
write_frequency ()
{
  return this->write_frequency_.get ();
}

void simulation_parameters::
write_frequency (const write_frequency_type& x)
{
  this->write_frequency_.set (x);
}

const simulation_parameters::r_cutoff_radius_type& simulation_parameters::
r_cutoff_radius () const
{
  return this->r_cutoff_radius_.get ();
}

simulation_parameters::r_cutoff_radius_type& simulation_parameters::
r_cutoff_radius ()
{
  return this->r_cutoff_radius_.get ();
}

void simulation_parameters::
r_cutoff_radius (const r_cutoff_radius_type& x)
{
  this->r_cutoff_radius_.set (x);
}

const simulation_parameters::domain_size_type& simulation_parameters::
domain_size () const
{
  return this->domain_size_.get ();
}

simulation_parameters::domain_size_type& simulation_parameters::
domain_size ()
{
  return this->domain_size_.get ();
}

void simulation_parameters::
domain_size (const domain_size_type& x)
{
  this->domain_size_.set (x);
}

void simulation_parameters::
domain_size (::std::auto_ptr< domain_size_type > x)
{
  this->domain_size_.set (x);
}


// cuboids
// 

const cuboids::cuboid_sequence& cuboids::
cuboid () const
{
  return this->cuboid_;
}

cuboids::cuboid_sequence& cuboids::
cuboid ()
{
  return this->cuboid_;
}

void cuboids::
cuboid (const cuboid_sequence& s)
{
  this->cuboid_ = s;
}


// domain_size
// 

const domain_size::x_type& domain_size::
x () const
{
  return this->x_.get ();
}

domain_size::x_type& domain_size::
x ()
{
  return this->x_.get ();
}

void domain_size::
x (const x_type& x)
{
  this->x_.set (x);
}

const domain_size::y_type& domain_size::
y () const
{
  return this->y_.get ();
}

domain_size::y_type& domain_size::
y ()
{
  return this->y_.get ();
}

void domain_size::
y (const y_type& x)
{
  this->y_.set (x);
}

const domain_size::z_type& domain_size::
z () const
{
  return this->z_.get ();
}

domain_size::z_type& domain_size::
z ()
{
  return this->z_.get ();
}

void domain_size::
z (const z_type& x)
{
  this->z_.set (x);
}


// cuboid
// 

const cuboid::coordinate_type& cuboid::
coordinate () const
{
  return this->coordinate_.get ();
}

cuboid::coordinate_type& cuboid::
coordinate ()
{
  return this->coordinate_.get ();
}

void cuboid::
coordinate (const coordinate_type& x)
{
  this->coordinate_.set (x);
}

void cuboid::
coordinate (::std::auto_ptr< coordinate_type > x)
{
  this->coordinate_.set (x);
}

const cuboid::dimensions_type& cuboid::
dimensions () const
{
  return this->dimensions_.get ();
}

cuboid::dimensions_type& cuboid::
dimensions ()
{
  return this->dimensions_.get ();
}

void cuboid::
dimensions (const dimensions_type& x)
{
  this->dimensions_.set (x);
}

void cuboid::
dimensions (::std::auto_ptr< dimensions_type > x)
{
  this->dimensions_.set (x);
}

const cuboid::mesh_width_type& cuboid::
mesh_width () const
{
  return this->mesh_width_.get ();
}

cuboid::mesh_width_type& cuboid::
mesh_width ()
{
  return this->mesh_width_.get ();
}

void cuboid::
mesh_width (const mesh_width_type& x)
{
  this->mesh_width_.set (x);
}

const cuboid::mass_type& cuboid::
mass () const
{
  return this->mass_.get ();
}

cuboid::mass_type& cuboid::
mass ()
{
  return this->mass_.get ();
}

void cuboid::
mass (const mass_type& x)
{
  this->mass_.set (x);
}

const cuboid::initial_velocity_type& cuboid::
initial_velocity () const
{
  return this->initial_velocity_.get ();
}

cuboid::initial_velocity_type& cuboid::
initial_velocity ()
{
  return this->initial_velocity_.get ();
}

void cuboid::
initial_velocity (const initial_velocity_type& x)
{
  this->initial_velocity_.set (x);
}

void cuboid::
initial_velocity (::std::auto_ptr< initial_velocity_type > x)
{
  this->initial_velocity_.set (x);
}

const cuboid::average_velocity_type& cuboid::
average_velocity () const
{
  return this->average_velocity_.get ();
}

cuboid::average_velocity_type& cuboid::
average_velocity ()
{
  return this->average_velocity_.get ();
}

void cuboid::
average_velocity (const average_velocity_type& x)
{
  this->average_velocity_.set (x);
}


// coordinate
// 

const coordinate::x_type& coordinate::
x () const
{
  return this->x_.get ();
}

coordinate::x_type& coordinate::
x ()
{
  return this->x_.get ();
}

void coordinate::
x (const x_type& x)
{
  this->x_.set (x);
}

const coordinate::y_type& coordinate::
y () const
{
  return this->y_.get ();
}

coordinate::y_type& coordinate::
y ()
{
  return this->y_.get ();
}

void coordinate::
y (const y_type& x)
{
  this->y_.set (x);
}

const coordinate::z_type& coordinate::
z () const
{
  return this->z_.get ();
}

coordinate::z_type& coordinate::
z ()
{
  return this->z_.get ();
}

void coordinate::
z (const z_type& x)
{
  this->z_.set (x);
}


// dimensions
// 

const dimensions::x_type& dimensions::
x () const
{
  return this->x_.get ();
}

dimensions::x_type& dimensions::
x ()
{
  return this->x_.get ();
}

void dimensions::
x (const x_type& x)
{
  this->x_.set (x);
}

const dimensions::y_type& dimensions::
y () const
{
  return this->y_.get ();
}

dimensions::y_type& dimensions::
y ()
{
  return this->y_.get ();
}

void dimensions::
y (const y_type& x)
{
  this->y_.set (x);
}

const dimensions::z_type& dimensions::
z () const
{
  return this->z_.get ();
}

dimensions::z_type& dimensions::
z ()
{
  return this->z_.get ();
}

void dimensions::
z (const z_type& x)
{
  this->z_.set (x);
}


// initial_velocity
// 

const initial_velocity::x_type& initial_velocity::
x () const
{
  return this->x_.get ();
}

initial_velocity::x_type& initial_velocity::
x ()
{
  return this->x_.get ();
}

void initial_velocity::
x (const x_type& x)
{
  this->x_.set (x);
}

const initial_velocity::y_type& initial_velocity::
y () const
{
  return this->y_.get ();
}

initial_velocity::y_type& initial_velocity::
y ()
{
  return this->y_.get ();
}

void initial_velocity::
y (const y_type& x)
{
  this->y_.set (x);
}

const initial_velocity::z_type& initial_velocity::
z () const
{
  return this->z_.get ();
}

initial_velocity::z_type& initial_velocity::
z ()
{
  return this->z_.get ();
}

void initial_velocity::
z (const z_type& x)
{
  this->z_.set (x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// MolSim
//

MolSim::
MolSim (const simulation_parameters_type& simulation_parameters,
        const cuboids_type& cuboids)
: ::xml_schema::type (),
  simulation_parameters_ (simulation_parameters, this),
  cuboids_ (cuboids, this)
{
}

MolSim::
MolSim (::std::auto_ptr< simulation_parameters_type > simulation_parameters,
        ::std::auto_ptr< cuboids_type > cuboids)
: ::xml_schema::type (),
  simulation_parameters_ (simulation_parameters, this),
  cuboids_ (cuboids, this)
{
}

MolSim::
MolSim (const MolSim& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  simulation_parameters_ (x.simulation_parameters_, f, this),
  cuboids_ (x.cuboids_, f, this)
{
}

MolSim::
MolSim (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  simulation_parameters_ (this),
  cuboids_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void MolSim::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // simulation_parameters
    //
    if (n.name () == "simulation_parameters" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< simulation_parameters_type > r (
        simulation_parameters_traits::create (i, f, this));

      if (!simulation_parameters_.present ())
      {
        this->simulation_parameters_.set (r);
        continue;
      }
    }

    // cuboids
    //
    if (n.name () == "cuboids" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< cuboids_type > r (
        cuboids_traits::create (i, f, this));

      if (!cuboids_.present ())
      {
        this->cuboids_.set (r);
        continue;
      }
    }

    break;
  }

  if (!simulation_parameters_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "simulation_parameters",
      "");
  }

  if (!cuboids_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "cuboids",
      "");
  }
}

MolSim* MolSim::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MolSim (*this, f, c);
}

MolSim& MolSim::
operator= (const MolSim& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->simulation_parameters_ = x.simulation_parameters_;
    this->cuboids_ = x.cuboids_;
  }

  return *this;
}

MolSim::
~MolSim ()
{
}

// simulation_parameters
//

simulation_parameters::
simulation_parameters (const end_time_type& end_time,
                       const delta_time_type& delta_time,
                       const output_basename_type& output_basename,
                       const write_frequency_type& write_frequency,
                       const r_cutoff_radius_type& r_cutoff_radius,
                       const domain_size_type& domain_size)
: ::xml_schema::type (),
  end_time_ (end_time, this),
  delta_time_ (delta_time, this),
  output_basename_ (output_basename, this),
  write_frequency_ (write_frequency, this),
  r_cutoff_radius_ (r_cutoff_radius, this),
  domain_size_ (domain_size, this)
{
}

simulation_parameters::
simulation_parameters (const end_time_type& end_time,
                       const delta_time_type& delta_time,
                       const output_basename_type& output_basename,
                       const write_frequency_type& write_frequency,
                       const r_cutoff_radius_type& r_cutoff_radius,
                       ::std::auto_ptr< domain_size_type > domain_size)
: ::xml_schema::type (),
  end_time_ (end_time, this),
  delta_time_ (delta_time, this),
  output_basename_ (output_basename, this),
  write_frequency_ (write_frequency, this),
  r_cutoff_radius_ (r_cutoff_radius, this),
  domain_size_ (domain_size, this)
{
}

simulation_parameters::
simulation_parameters (const simulation_parameters& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  end_time_ (x.end_time_, f, this),
  delta_time_ (x.delta_time_, f, this),
  output_basename_ (x.output_basename_, f, this),
  write_frequency_ (x.write_frequency_, f, this),
  r_cutoff_radius_ (x.r_cutoff_radius_, f, this),
  domain_size_ (x.domain_size_, f, this)
{
}

simulation_parameters::
simulation_parameters (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  end_time_ (this),
  delta_time_ (this),
  output_basename_ (this),
  write_frequency_ (this),
  r_cutoff_radius_ (this),
  domain_size_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void simulation_parameters::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // end_time
    //
    if (n.name () == "end_time" && n.namespace_ ().empty ())
    {
      if (!end_time_.present ())
      {
        this->end_time_.set (end_time_traits::create (i, f, this));
        continue;
      }
    }

    // delta_time
    //
    if (n.name () == "delta_time" && n.namespace_ ().empty ())
    {
      if (!delta_time_.present ())
      {
        this->delta_time_.set (delta_time_traits::create (i, f, this));
        continue;
      }
    }

    // output_basename
    //
    if (n.name () == "output_basename" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< output_basename_type > r (
        output_basename_traits::create (i, f, this));

      if (!output_basename_.present ())
      {
        this->output_basename_.set (r);
        continue;
      }
    }

    // write_frequency
    //
    if (n.name () == "write_frequency" && n.namespace_ ().empty ())
    {
      if (!write_frequency_.present ())
      {
        this->write_frequency_.set (write_frequency_traits::create (i, f, this));
        continue;
      }
    }

    // r_cutoff_radius
    //
    if (n.name () == "r_cutoff_radius" && n.namespace_ ().empty ())
    {
      if (!r_cutoff_radius_.present ())
      {
        this->r_cutoff_radius_.set (r_cutoff_radius_traits::create (i, f, this));
        continue;
      }
    }

    // domain_size
    //
    if (n.name () == "domain_size" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< domain_size_type > r (
        domain_size_traits::create (i, f, this));

      if (!domain_size_.present ())
      {
        this->domain_size_.set (r);
        continue;
      }
    }

    break;
  }

  if (!end_time_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "end_time",
      "");
  }

  if (!delta_time_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "delta_time",
      "");
  }

  if (!output_basename_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "output_basename",
      "");
  }

  if (!write_frequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "write_frequency",
      "");
  }

  if (!r_cutoff_radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "r_cutoff_radius",
      "");
  }

  if (!domain_size_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "domain_size",
      "");
  }
}

simulation_parameters* simulation_parameters::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class simulation_parameters (*this, f, c);
}

simulation_parameters& simulation_parameters::
operator= (const simulation_parameters& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->end_time_ = x.end_time_;
    this->delta_time_ = x.delta_time_;
    this->output_basename_ = x.output_basename_;
    this->write_frequency_ = x.write_frequency_;
    this->r_cutoff_radius_ = x.r_cutoff_radius_;
    this->domain_size_ = x.domain_size_;
  }

  return *this;
}

simulation_parameters::
~simulation_parameters ()
{
}

// cuboids
//

cuboids::
cuboids ()
: ::xml_schema::type (),
  cuboid_ (this)
{
}

cuboids::
cuboids (const cuboids& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  cuboid_ (x.cuboid_, f, this)
{
}

cuboids::
cuboids (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  cuboid_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void cuboids::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // cuboid
    //
    if (n.name () == "cuboid" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< cuboid_type > r (
        cuboid_traits::create (i, f, this));

      this->cuboid_.push_back (r);
      continue;
    }

    break;
  }
}

cuboids* cuboids::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class cuboids (*this, f, c);
}

cuboids& cuboids::
operator= (const cuboids& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->cuboid_ = x.cuboid_;
  }

  return *this;
}

cuboids::
~cuboids ()
{
}

// domain_size
//

domain_size::
domain_size (const x_type& x,
             const y_type& y,
             const z_type& z)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (z, this)
{
}

domain_size::
domain_size (const domain_size& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

domain_size::
domain_size (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void domain_size::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // x
    //
    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      if (!x_.present ())
      {
        this->x_.set (x_traits::create (i, f, this));
        continue;
      }
    }

    // y
    //
    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      if (!y_.present ())
      {
        this->y_.set (y_traits::create (i, f, this));
        continue;
      }
    }

    // z
    //
    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      if (!z_.present ())
      {
        this->z_.set (z_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "y",
      "");
  }

  if (!z_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "z",
      "");
  }
}

domain_size* domain_size::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class domain_size (*this, f, c);
}

domain_size& domain_size::
operator= (const domain_size& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

domain_size::
~domain_size ()
{
}

// cuboid
//

cuboid::
cuboid (const coordinate_type& coordinate,
        const dimensions_type& dimensions,
        const mesh_width_type& mesh_width,
        const mass_type& mass,
        const initial_velocity_type& initial_velocity,
        const average_velocity_type& average_velocity)
: ::xml_schema::type (),
  coordinate_ (coordinate, this),
  dimensions_ (dimensions, this),
  mesh_width_ (mesh_width, this),
  mass_ (mass, this),
  initial_velocity_ (initial_velocity, this),
  average_velocity_ (average_velocity, this)
{
}

cuboid::
cuboid (::std::auto_ptr< coordinate_type > coordinate,
        ::std::auto_ptr< dimensions_type > dimensions,
        const mesh_width_type& mesh_width,
        const mass_type& mass,
        ::std::auto_ptr< initial_velocity_type > initial_velocity,
        const average_velocity_type& average_velocity)
: ::xml_schema::type (),
  coordinate_ (coordinate, this),
  dimensions_ (dimensions, this),
  mesh_width_ (mesh_width, this),
  mass_ (mass, this),
  initial_velocity_ (initial_velocity, this),
  average_velocity_ (average_velocity, this)
{
}

cuboid::
cuboid (const cuboid& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  coordinate_ (x.coordinate_, f, this),
  dimensions_ (x.dimensions_, f, this),
  mesh_width_ (x.mesh_width_, f, this),
  mass_ (x.mass_, f, this),
  initial_velocity_ (x.initial_velocity_, f, this),
  average_velocity_ (x.average_velocity_, f, this)
{
}

cuboid::
cuboid (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  coordinate_ (this),
  dimensions_ (this),
  mesh_width_ (this),
  mass_ (this),
  initial_velocity_ (this),
  average_velocity_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void cuboid::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // coordinate
    //
    if (n.name () == "coordinate" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< coordinate_type > r (
        coordinate_traits::create (i, f, this));

      if (!coordinate_.present ())
      {
        this->coordinate_.set (r);
        continue;
      }
    }

    // dimensions
    //
    if (n.name () == "dimensions" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dimensions_type > r (
        dimensions_traits::create (i, f, this));

      if (!dimensions_.present ())
      {
        this->dimensions_.set (r);
        continue;
      }
    }

    // mesh_width
    //
    if (n.name () == "mesh_width" && n.namespace_ ().empty ())
    {
      if (!mesh_width_.present ())
      {
        this->mesh_width_.set (mesh_width_traits::create (i, f, this));
        continue;
      }
    }

    // mass
    //
    if (n.name () == "mass" && n.namespace_ ().empty ())
    {
      if (!mass_.present ())
      {
        this->mass_.set (mass_traits::create (i, f, this));
        continue;
      }
    }

    // initial_velocity
    //
    if (n.name () == "initial_velocity" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< initial_velocity_type > r (
        initial_velocity_traits::create (i, f, this));

      if (!initial_velocity_.present ())
      {
        this->initial_velocity_.set (r);
        continue;
      }
    }

    // average_velocity
    //
    if (n.name () == "average_velocity" && n.namespace_ ().empty ())
    {
      if (!average_velocity_.present ())
      {
        this->average_velocity_.set (average_velocity_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!coordinate_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "coordinate",
      "");
  }

  if (!dimensions_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "dimensions",
      "");
  }

  if (!mesh_width_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mesh_width",
      "");
  }

  if (!mass_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mass",
      "");
  }

  if (!initial_velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "initial_velocity",
      "");
  }

  if (!average_velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "average_velocity",
      "");
  }
}

cuboid* cuboid::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class cuboid (*this, f, c);
}

cuboid& cuboid::
operator= (const cuboid& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->coordinate_ = x.coordinate_;
    this->dimensions_ = x.dimensions_;
    this->mesh_width_ = x.mesh_width_;
    this->mass_ = x.mass_;
    this->initial_velocity_ = x.initial_velocity_;
    this->average_velocity_ = x.average_velocity_;
  }

  return *this;
}

cuboid::
~cuboid ()
{
}

// coordinate
//

coordinate::
coordinate (const x_type& x,
            const y_type& y,
            const z_type& z)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (z, this)
{
}

coordinate::
coordinate (const coordinate& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

coordinate::
coordinate (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void coordinate::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // x
    //
    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      if (!x_.present ())
      {
        this->x_.set (x_traits::create (i, f, this));
        continue;
      }
    }

    // y
    //
    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      if (!y_.present ())
      {
        this->y_.set (y_traits::create (i, f, this));
        continue;
      }
    }

    // z
    //
    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      if (!z_.present ())
      {
        this->z_.set (z_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "y",
      "");
  }

  if (!z_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "z",
      "");
  }
}

coordinate* coordinate::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class coordinate (*this, f, c);
}

coordinate& coordinate::
operator= (const coordinate& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

coordinate::
~coordinate ()
{
}

// dimensions
//

dimensions::
dimensions (const x_type& x,
            const y_type& y,
            const z_type& z)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (z, this)
{
}

dimensions::
dimensions (const dimensions& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

dimensions::
dimensions (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void dimensions::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // x
    //
    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      if (!x_.present ())
      {
        this->x_.set (x_traits::create (i, f, this));
        continue;
      }
    }

    // y
    //
    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      if (!y_.present ())
      {
        this->y_.set (y_traits::create (i, f, this));
        continue;
      }
    }

    // z
    //
    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      if (!z_.present ())
      {
        this->z_.set (z_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "y",
      "");
  }

  if (!z_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "z",
      "");
  }
}

dimensions* dimensions::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class dimensions (*this, f, c);
}

dimensions& dimensions::
operator= (const dimensions& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

dimensions::
~dimensions ()
{
}

// initial_velocity
//

initial_velocity::
initial_velocity (const x_type& x,
                  const y_type& y,
                  const z_type& z)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (z, this)
{
}

initial_velocity::
initial_velocity (const initial_velocity& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

initial_velocity::
initial_velocity (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void initial_velocity::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // x
    //
    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      if (!x_.present ())
      {
        this->x_.set (x_traits::create (i, f, this));
        continue;
      }
    }

    // y
    //
    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      if (!y_.present ())
      {
        this->y_.set (y_traits::create (i, f, this));
        continue;
      }
    }

    // z
    //
    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      if (!z_.present ())
      {
        this->z_.set (z_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "y",
      "");
  }

  if (!z_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "z",
      "");
  }
}

initial_velocity* initial_velocity::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class initial_velocity (*this, f, c);
}

initial_velocity& initial_velocity::
operator= (const initial_velocity& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

initial_velocity::
~initial_velocity ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::MolSim >
MolSim_ (const ::std::string& u,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::MolSim > (
    ::MolSim_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::MolSim >
MolSim_ (const ::std::string& u,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::MolSim > (
    ::MolSim_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::MolSim >
MolSim_ (const ::std::string& u,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::MolSim > (
    ::MolSim_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::MolSim >
MolSim_ (::std::istream& is,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::MolSim_ (isrc, f, p);
}

::std::auto_ptr< ::MolSim >
MolSim_ (::std::istream& is,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::MolSim_ (isrc, h, f, p);
}

::std::auto_ptr< ::MolSim >
MolSim_ (::std::istream& is,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::MolSim_ (isrc, h, f, p);
}

::std::auto_ptr< ::MolSim >
MolSim_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::MolSim_ (isrc, f, p);
}

::std::auto_ptr< ::MolSim >
MolSim_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::MolSim_ (isrc, h, f, p);
}

::std::auto_ptr< ::MolSim >
MolSim_ (::std::istream& is,
         const ::std::string& sid,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::MolSim_ (isrc, h, f, p);
}

::std::auto_ptr< ::MolSim >
MolSim_ (::xercesc::InputSource& i,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::MolSim > (
    ::MolSim_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::MolSim >
MolSim_ (::xercesc::InputSource& i,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::MolSim > (
    ::MolSim_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::MolSim >
MolSim_ (::xercesc::InputSource& i,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::MolSim > (
    ::MolSim_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::MolSim >
MolSim_ (const ::xercesc::DOMDocument& doc,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::MolSim > (
      ::MolSim_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "MolSim" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::MolSim > r (
      ::xsd::cxx::tree::traits< ::MolSim, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "MolSim",
    "");
}

::std::auto_ptr< ::MolSim >
MolSim_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
         ::xml_schema::flags f,
         const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "MolSim" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::MolSim > r (
      ::xsd::cxx::tree::traits< ::MolSim, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "MolSim",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

