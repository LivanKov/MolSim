// Copyright (c) 2005-2023 Code Synthesis.
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis gives permission
// to link this program with the Xerces-C++ library (or with modified
// versions of Xerces-C++ that use the same license as Xerces-C++), and
// distribute linked combinations including the two. You must obey the GNU
// General Public License version 2 in all respects for all of the code
// used other than Xerces-C++. If you modify this copy of the program, you
// may extend this exception to your version of the program, but you are
// not obligated to do so. If you do not wish to do so, delete this
// exception statement from your version.
//
// Furthermore, Code Synthesis makes a special exception for the Free/Libre
// and Open Source Software (FLOSS) which is described in the accompanying
// FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "MolSim.hxx"

// boundary_condition_type
//

boundary_condition_type::
boundary_condition_type (value v)
: ::xml_schema::string (_xsd_boundary_condition_type_literals_[v])
{
}

boundary_condition_type::
boundary_condition_type (const char* v)
: ::xml_schema::string (v)
{
}

boundary_condition_type::
boundary_condition_type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

boundary_condition_type::
boundary_condition_type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

boundary_condition_type::
boundary_condition_type (const boundary_condition_type& v,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

boundary_condition_type& boundary_condition_type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_boundary_condition_type_literals_[v]);

  return *this;
}


// MolSim
//

const MolSim::simulation_parameters_type& MolSim::
simulation_parameters () const
{
  return this->simulation_parameters_.get ();
}

MolSim::simulation_parameters_type& MolSim::
simulation_parameters ()
{
  return this->simulation_parameters_.get ();
}

void MolSim::
simulation_parameters (const simulation_parameters_type& x)
{
  this->simulation_parameters_.set (x);
}

void MolSim::
simulation_parameters (::std::unique_ptr< simulation_parameters_type > x)
{
  this->simulation_parameters_.set (std::move (x));
}

const MolSim::thermostats_optional& MolSim::
thermostats () const
{
  return this->thermostats_;
}

MolSim::thermostats_optional& MolSim::
thermostats ()
{
  return this->thermostats_;
}

void MolSim::
thermostats (const thermostats_type& x)
{
  this->thermostats_.set (x);
}

void MolSim::
thermostats (const thermostats_optional& x)
{
  this->thermostats_ = x;
}

void MolSim::
thermostats (::std::unique_ptr< thermostats_type > x)
{
  this->thermostats_.set (std::move (x));
}

const MolSim::boundary_conditions_optional& MolSim::
boundary_conditions () const
{
  return this->boundary_conditions_;
}

MolSim::boundary_conditions_optional& MolSim::
boundary_conditions ()
{
  return this->boundary_conditions_;
}

void MolSim::
boundary_conditions (const boundary_conditions_type& x)
{
  this->boundary_conditions_.set (x);
}

void MolSim::
boundary_conditions (const boundary_conditions_optional& x)
{
  this->boundary_conditions_ = x;
}

void MolSim::
boundary_conditions (::std::unique_ptr< boundary_conditions_type > x)
{
  this->boundary_conditions_.set (std::move (x));
}

const MolSim::discs_optional& MolSim::
discs () const
{
  return this->discs_;
}

MolSim::discs_optional& MolSim::
discs ()
{
  return this->discs_;
}

void MolSim::
discs (const discs_type& x)
{
  this->discs_.set (x);
}

void MolSim::
discs (const discs_optional& x)
{
  this->discs_ = x;
}

void MolSim::
discs (::std::unique_ptr< discs_type > x)
{
  this->discs_.set (std::move (x));
}

const MolSim::cuboids_optional& MolSim::
cuboids () const
{
  return this->cuboids_;
}

MolSim::cuboids_optional& MolSim::
cuboids ()
{
  return this->cuboids_;
}

void MolSim::
cuboids (const cuboids_type& x)
{
  this->cuboids_.set (x);
}

void MolSim::
cuboids (const cuboids_optional& x)
{
  this->cuboids_ = x;
}

void MolSim::
cuboids (::std::unique_ptr< cuboids_type > x)
{
  this->cuboids_.set (std::move (x));
}

const MolSim::particles_optional& MolSim::
particles () const
{
  return this->particles_;
}

MolSim::particles_optional& MolSim::
particles ()
{
  return this->particles_;
}

void MolSim::
particles (const particles_type& x)
{
  this->particles_.set (x);
}

void MolSim::
particles (const particles_optional& x)
{
  this->particles_ = x;
}

void MolSim::
particles (::std::unique_ptr< particles_type > x)
{
  this->particles_.set (std::move (x));
}


// simulation_parameters
//

const simulation_parameters::end_time_type& simulation_parameters::
end_time () const
{
  return this->end_time_.get ();
}

simulation_parameters::end_time_type& simulation_parameters::
end_time ()
{
  return this->end_time_.get ();
}

void simulation_parameters::
end_time (const end_time_type& x)
{
  this->end_time_.set (x);
}

const simulation_parameters::delta_time_type& simulation_parameters::
delta_time () const
{
  return this->delta_time_.get ();
}

simulation_parameters::delta_time_type& simulation_parameters::
delta_time ()
{
  return this->delta_time_.get ();
}

void simulation_parameters::
delta_time (const delta_time_type& x)
{
  this->delta_time_.set (x);
}

const simulation_parameters::output_basename_type& simulation_parameters::
output_basename () const
{
  return this->output_basename_.get ();
}

simulation_parameters::output_basename_type& simulation_parameters::
output_basename ()
{
  return this->output_basename_.get ();
}

void simulation_parameters::
output_basename (const output_basename_type& x)
{
  this->output_basename_.set (x);
}

void simulation_parameters::
output_basename (::std::unique_ptr< output_basename_type > x)
{
  this->output_basename_.set (std::move (x));
}

const simulation_parameters::write_frequency_type& simulation_parameters::
write_frequency () const
{
  return this->write_frequency_.get ();
}

simulation_parameters::write_frequency_type& simulation_parameters::
write_frequency ()
{
  return this->write_frequency_.get ();
}

void simulation_parameters::
write_frequency (const write_frequency_type& x)
{
  this->write_frequency_.set (x);
}

const simulation_parameters::r_cutoff_radius_type& simulation_parameters::
r_cutoff_radius () const
{
  return this->r_cutoff_radius_.get ();
}

simulation_parameters::r_cutoff_radius_type& simulation_parameters::
r_cutoff_radius ()
{
  return this->r_cutoff_radius_.get ();
}

void simulation_parameters::
r_cutoff_radius (const r_cutoff_radius_type& x)
{
  this->r_cutoff_radius_.set (x);
}

const simulation_parameters::gravity_optional& simulation_parameters::
gravity () const
{
  return this->gravity_;
}

simulation_parameters::gravity_optional& simulation_parameters::
gravity ()
{
  return this->gravity_;
}

void simulation_parameters::
gravity (const gravity_type& x)
{
  this->gravity_.set (x);
}

void simulation_parameters::
gravity (const gravity_optional& x)
{
  this->gravity_ = x;
}

const simulation_parameters::zgravity_optional& simulation_parameters::
zgravity () const
{
  return this->zgravity_;
}

simulation_parameters::zgravity_optional& simulation_parameters::
zgravity ()
{
  return this->zgravity_;
}

void simulation_parameters::
zgravity (const zgravity_type& x)
{
  this->zgravity_.set (x);
}

void simulation_parameters::
zgravity (const zgravity_optional& x)
{
  this->zgravity_ = x;
}

const simulation_parameters::enable_brownian_type& simulation_parameters::
enable_brownian () const
{
  return this->enable_brownian_.get ();
}

simulation_parameters::enable_brownian_type& simulation_parameters::
enable_brownian ()
{
  return this->enable_brownian_.get ();
}

void simulation_parameters::
enable_brownian (const enable_brownian_type& x)
{
  this->enable_brownian_.set (x);
}

const simulation_parameters::domain_size_optional& simulation_parameters::
domain_size () const
{
  return this->domain_size_;
}

simulation_parameters::domain_size_optional& simulation_parameters::
domain_size ()
{
  return this->domain_size_;
}

void simulation_parameters::
domain_size (const domain_size_type& x)
{
  this->domain_size_.set (x);
}

void simulation_parameters::
domain_size (const domain_size_optional& x)
{
  this->domain_size_ = x;
}

void simulation_parameters::
domain_size (::std::unique_ptr< domain_size_type > x)
{
  this->domain_size_.set (std::move (x));
}


// thermostats
//

const thermostats::initial_temp_type& thermostats::
initial_temp () const
{
  return this->initial_temp_.get ();
}

thermostats::initial_temp_type& thermostats::
initial_temp ()
{
  return this->initial_temp_.get ();
}

void thermostats::
initial_temp (const initial_temp_type& x)
{
  this->initial_temp_.set (x);
}

const thermostats::target_temp_type& thermostats::
target_temp () const
{
  return this->target_temp_.get ();
}

thermostats::target_temp_type& thermostats::
target_temp ()
{
  return this->target_temp_.get ();
}

void thermostats::
target_temp (const target_temp_type& x)
{
  this->target_temp_.set (x);
}

const thermostats::delta_temp_type& thermostats::
delta_temp () const
{
  return this->delta_temp_.get ();
}

thermostats::delta_temp_type& thermostats::
delta_temp ()
{
  return this->delta_temp_.get ();
}

void thermostats::
delta_temp (const delta_temp_type& x)
{
  this->delta_temp_.set (x);
}

const thermostats::is_gradual_type& thermostats::
is_gradual () const
{
  return this->is_gradual_.get ();
}

thermostats::is_gradual_type& thermostats::
is_gradual ()
{
  return this->is_gradual_.get ();
}

void thermostats::
is_gradual (const is_gradual_type& x)
{
  this->is_gradual_.set (x);
}

const thermostats::n_thermostats_type& thermostats::
n_thermostats () const
{
  return this->n_thermostats_.get ();
}

thermostats::n_thermostats_type& thermostats::
n_thermostats ()
{
  return this->n_thermostats_.get ();
}

void thermostats::
n_thermostats (const n_thermostats_type& x)
{
  this->n_thermostats_.set (x);
}


// boundary_conditions
//

const boundary_conditions::left_type& boundary_conditions::
left () const
{
  return this->left_.get ();
}

boundary_conditions::left_type& boundary_conditions::
left ()
{
  return this->left_.get ();
}

void boundary_conditions::
left (const left_type& x)
{
  this->left_.set (x);
}

void boundary_conditions::
left (::std::unique_ptr< left_type > x)
{
  this->left_.set (std::move (x));
}

const boundary_conditions::right_type& boundary_conditions::
right () const
{
  return this->right_.get ();
}

boundary_conditions::right_type& boundary_conditions::
right ()
{
  return this->right_.get ();
}

void boundary_conditions::
right (const right_type& x)
{
  this->right_.set (x);
}

void boundary_conditions::
right (::std::unique_ptr< right_type > x)
{
  this->right_.set (std::move (x));
}

const boundary_conditions::top_type& boundary_conditions::
top () const
{
  return this->top_.get ();
}

boundary_conditions::top_type& boundary_conditions::
top ()
{
  return this->top_.get ();
}

void boundary_conditions::
top (const top_type& x)
{
  this->top_.set (x);
}

void boundary_conditions::
top (::std::unique_ptr< top_type > x)
{
  this->top_.set (std::move (x));
}

const boundary_conditions::bottom_type& boundary_conditions::
bottom () const
{
  return this->bottom_.get ();
}

boundary_conditions::bottom_type& boundary_conditions::
bottom ()
{
  return this->bottom_.get ();
}

void boundary_conditions::
bottom (const bottom_type& x)
{
  this->bottom_.set (x);
}

void boundary_conditions::
bottom (::std::unique_ptr< bottom_type > x)
{
  this->bottom_.set (std::move (x));
}

const boundary_conditions::front_optional& boundary_conditions::
front () const
{
  return this->front_;
}

boundary_conditions::front_optional& boundary_conditions::
front ()
{
  return this->front_;
}

void boundary_conditions::
front (const front_type& x)
{
  this->front_.set (x);
}

void boundary_conditions::
front (const front_optional& x)
{
  this->front_ = x;
}

void boundary_conditions::
front (::std::unique_ptr< front_type > x)
{
  this->front_.set (std::move (x));
}

const boundary_conditions::back_optional& boundary_conditions::
back () const
{
  return this->back_;
}

boundary_conditions::back_optional& boundary_conditions::
back ()
{
  return this->back_;
}

void boundary_conditions::
back (const back_type& x)
{
  this->back_.set (x);
}

void boundary_conditions::
back (const back_optional& x)
{
  this->back_ = x;
}

void boundary_conditions::
back (::std::unique_ptr< back_type > x)
{
  this->back_.set (std::move (x));
}


// discs
//

const discs::disc_sequence& discs::
disc () const
{
  return this->disc_;
}

discs::disc_sequence& discs::
disc ()
{
  return this->disc_;
}

void discs::
disc (const disc_sequence& s)
{
  this->disc_ = s;
}


// cuboids
//

const cuboids::cuboid_sequence& cuboids::
cuboid () const
{
  return this->cuboid_;
}

cuboids::cuboid_sequence& cuboids::
cuboid ()
{
  return this->cuboid_;
}

void cuboids::
cuboid (const cuboid_sequence& s)
{
  this->cuboid_ = s;
}


// particles
//

const particles::particle_sequence& particles::
particle () const
{
  return this->particle_;
}

particles::particle_sequence& particles::
particle ()
{
  return this->particle_;
}

void particles::
particle (const particle_sequence& s)
{
  this->particle_ = s;
}


// domain_size
//

const domain_size::x_type& domain_size::
x () const
{
  return this->x_.get ();
}

domain_size::x_type& domain_size::
x ()
{
  return this->x_.get ();
}

void domain_size::
x (const x_type& x)
{
  this->x_.set (x);
}

const domain_size::y_type& domain_size::
y () const
{
  return this->y_.get ();
}

domain_size::y_type& domain_size::
y ()
{
  return this->y_.get ();
}

void domain_size::
y (const y_type& x)
{
  this->y_.set (x);
}

const domain_size::z_type& domain_size::
z () const
{
  return this->z_.get ();
}

domain_size::z_type& domain_size::
z ()
{
  return this->z_.get ();
}

void domain_size::
z (const z_type& x)
{
  this->z_.set (x);
}

const domain_size::lower_left_corner_optional& domain_size::
lower_left_corner () const
{
  return this->lower_left_corner_;
}

domain_size::lower_left_corner_optional& domain_size::
lower_left_corner ()
{
  return this->lower_left_corner_;
}

void domain_size::
lower_left_corner (const lower_left_corner_type& x)
{
  this->lower_left_corner_.set (x);
}

void domain_size::
lower_left_corner (const lower_left_corner_optional& x)
{
  this->lower_left_corner_ = x;
}

void domain_size::
lower_left_corner (::std::unique_ptr< lower_left_corner_type > x)
{
  this->lower_left_corner_.set (std::move (x));
}


// disc
//

const disc::center_type& disc::
center () const
{
  return this->center_.get ();
}

disc::center_type& disc::
center ()
{
  return this->center_.get ();
}

void disc::
center (const center_type& x)
{
  this->center_.set (x);
}

void disc::
center (::std::unique_ptr< center_type > x)
{
  this->center_.set (std::move (x));
}

const disc::initial_velocity_type& disc::
initial_velocity () const
{
  return this->initial_velocity_.get ();
}

disc::initial_velocity_type& disc::
initial_velocity ()
{
  return this->initial_velocity_.get ();
}

void disc::
initial_velocity (const initial_velocity_type& x)
{
  this->initial_velocity_.set (x);
}

void disc::
initial_velocity (::std::unique_ptr< initial_velocity_type > x)
{
  this->initial_velocity_.set (std::move (x));
}

const disc::radius_type& disc::
radius () const
{
  return this->radius_.get ();
}

disc::radius_type& disc::
radius ()
{
  return this->radius_.get ();
}

void disc::
radius (const radius_type& x)
{
  this->radius_.set (x);
}

const disc::mesh_width_type& disc::
mesh_width () const
{
  return this->mesh_width_.get ();
}

disc::mesh_width_type& disc::
mesh_width ()
{
  return this->mesh_width_.get ();
}

void disc::
mesh_width (const mesh_width_type& x)
{
  this->mesh_width_.set (x);
}

const disc::mass_type& disc::
mass () const
{
  return this->mass_.get ();
}

disc::mass_type& disc::
mass ()
{
  return this->mass_.get ();
}

void disc::
mass (const mass_type& x)
{
  this->mass_.set (x);
}

const disc::epsilon_type& disc::
epsilon () const
{
  return this->epsilon_.get ();
}

disc::epsilon_type& disc::
epsilon ()
{
  return this->epsilon_.get ();
}

void disc::
epsilon (const epsilon_type& x)
{
  this->epsilon_.set (x);
}

const disc::sigma_type& disc::
sigma () const
{
  return this->sigma_.get ();
}

disc::sigma_type& disc::
sigma ()
{
  return this->sigma_.get ();
}

void disc::
sigma (const sigma_type& x)
{
  this->sigma_.set (x);
}


// cuboid
//

const cuboid::coordinate_type& cuboid::
coordinate () const
{
  return this->coordinate_.get ();
}

cuboid::coordinate_type& cuboid::
coordinate ()
{
  return this->coordinate_.get ();
}

void cuboid::
coordinate (const coordinate_type& x)
{
  this->coordinate_.set (x);
}

void cuboid::
coordinate (::std::unique_ptr< coordinate_type > x)
{
  this->coordinate_.set (std::move (x));
}

const cuboid::dimensions_type& cuboid::
dimensions () const
{
  return this->dimensions_.get ();
}

cuboid::dimensions_type& cuboid::
dimensions ()
{
  return this->dimensions_.get ();
}

void cuboid::
dimensions (const dimensions_type& x)
{
  this->dimensions_.set (x);
}

void cuboid::
dimensions (::std::unique_ptr< dimensions_type > x)
{
  this->dimensions_.set (std::move (x));
}

const cuboid::mesh_width_type& cuboid::
mesh_width () const
{
  return this->mesh_width_.get ();
}

cuboid::mesh_width_type& cuboid::
mesh_width ()
{
  return this->mesh_width_.get ();
}

void cuboid::
mesh_width (const mesh_width_type& x)
{
  this->mesh_width_.set (x);
}

const cuboid::mass_type& cuboid::
mass () const
{
  return this->mass_.get ();
}

cuboid::mass_type& cuboid::
mass ()
{
  return this->mass_.get ();
}

void cuboid::
mass (const mass_type& x)
{
  this->mass_.set (x);
}

const cuboid::epsilon_type& cuboid::
epsilon () const
{
  return this->epsilon_.get ();
}

cuboid::epsilon_type& cuboid::
epsilon ()
{
  return this->epsilon_.get ();
}

void cuboid::
epsilon (const epsilon_type& x)
{
  this->epsilon_.set (x);
}

const cuboid::sigma_type& cuboid::
sigma () const
{
  return this->sigma_.get ();
}

cuboid::sigma_type& cuboid::
sigma ()
{
  return this->sigma_.get ();
}

void cuboid::
sigma (const sigma_type& x)
{
  this->sigma_.set (x);
}

const cuboid::initial_velocity_type& cuboid::
initial_velocity () const
{
  return this->initial_velocity_.get ();
}

cuboid::initial_velocity_type& cuboid::
initial_velocity ()
{
  return this->initial_velocity_.get ();
}

void cuboid::
initial_velocity (const initial_velocity_type& x)
{
  this->initial_velocity_.set (x);
}

void cuboid::
initial_velocity (::std::unique_ptr< initial_velocity_type > x)
{
  this->initial_velocity_.set (std::move (x));
}

const cuboid::additional_force_optional& cuboid::
additional_force () const
{
  return this->additional_force_;
}

cuboid::additional_force_optional& cuboid::
additional_force ()
{
  return this->additional_force_;
}

void cuboid::
additional_force (const additional_force_type& x)
{
  this->additional_force_.set (x);
}

void cuboid::
additional_force (const additional_force_optional& x)
{
  this->additional_force_ = x;
}

void cuboid::
additional_force (::std::unique_ptr< additional_force_type > x)
{
  this->additional_force_.set (std::move (x));
}

const cuboid::membrane_optional& cuboid::
membrane () const
{
  return this->membrane_;
}

cuboid::membrane_optional& cuboid::
membrane ()
{
  return this->membrane_;
}

void cuboid::
membrane (const membrane_type& x)
{
  this->membrane_.set (x);
}

void cuboid::
membrane (const membrane_optional& x)
{
  this->membrane_ = x;
}

void cuboid::
membrane (::std::unique_ptr< membrane_type > x)
{
  this->membrane_.set (std::move (x));
}

const cuboid::fixed_optional& cuboid::
fixed () const
{
  return this->fixed_;
}

cuboid::fixed_optional& cuboid::
fixed ()
{
  return this->fixed_;
}

void cuboid::
fixed (const fixed_type& x)
{
  this->fixed_.set (x);
}

void cuboid::
fixed (const fixed_optional& x)
{
  this->fixed_ = x;
}


// particle
//

const particle::position_type& particle::
position () const
{
  return this->position_.get ();
}

particle::position_type& particle::
position ()
{
  return this->position_.get ();
}

void particle::
position (const position_type& x)
{
  this->position_.set (x);
}

void particle::
position (::std::unique_ptr< position_type > x)
{
  this->position_.set (std::move (x));
}

const particle::velocity_type& particle::
velocity () const
{
  return this->velocity_.get ();
}

particle::velocity_type& particle::
velocity ()
{
  return this->velocity_.get ();
}

void particle::
velocity (const velocity_type& x)
{
  this->velocity_.set (x);
}

void particle::
velocity (::std::unique_ptr< velocity_type > x)
{
  this->velocity_.set (std::move (x));
}

const particle::mass_type& particle::
mass () const
{
  return this->mass_.get ();
}

particle::mass_type& particle::
mass ()
{
  return this->mass_.get ();
}

void particle::
mass (const mass_type& x)
{
  this->mass_.set (x);
}


// lower_left_corner
//

const lower_left_corner::x_type& lower_left_corner::
x () const
{
  return this->x_.get ();
}

lower_left_corner::x_type& lower_left_corner::
x ()
{
  return this->x_.get ();
}

void lower_left_corner::
x (const x_type& x)
{
  this->x_.set (x);
}

const lower_left_corner::y_type& lower_left_corner::
y () const
{
  return this->y_.get ();
}

lower_left_corner::y_type& lower_left_corner::
y ()
{
  return this->y_.get ();
}

void lower_left_corner::
y (const y_type& x)
{
  this->y_.set (x);
}

const lower_left_corner::z_type& lower_left_corner::
z () const
{
  return this->z_.get ();
}

lower_left_corner::z_type& lower_left_corner::
z ()
{
  return this->z_.get ();
}

void lower_left_corner::
z (const z_type& x)
{
  this->z_.set (x);
}


// center
//

const center::x_type& center::
x () const
{
  return this->x_.get ();
}

center::x_type& center::
x ()
{
  return this->x_.get ();
}

void center::
x (const x_type& x)
{
  this->x_.set (x);
}

const center::y_type& center::
y () const
{
  return this->y_.get ();
}

center::y_type& center::
y ()
{
  return this->y_.get ();
}

void center::
y (const y_type& x)
{
  this->y_.set (x);
}

const center::z_type& center::
z () const
{
  return this->z_.get ();
}

center::z_type& center::
z ()
{
  return this->z_.get ();
}

void center::
z (const z_type& x)
{
  this->z_.set (x);
}


// initial_velocity
//

const initial_velocity::x_type& initial_velocity::
x () const
{
  return this->x_.get ();
}

initial_velocity::x_type& initial_velocity::
x ()
{
  return this->x_.get ();
}

void initial_velocity::
x (const x_type& x)
{
  this->x_.set (x);
}

const initial_velocity::y_type& initial_velocity::
y () const
{
  return this->y_.get ();
}

initial_velocity::y_type& initial_velocity::
y ()
{
  return this->y_.get ();
}

void initial_velocity::
y (const y_type& x)
{
  this->y_.set (x);
}

const initial_velocity::z_type& initial_velocity::
z () const
{
  return this->z_.get ();
}

initial_velocity::z_type& initial_velocity::
z ()
{
  return this->z_.get ();
}

void initial_velocity::
z (const z_type& x)
{
  this->z_.set (x);
}


// coordinate
//

const coordinate::x_type& coordinate::
x () const
{
  return this->x_.get ();
}

coordinate::x_type& coordinate::
x ()
{
  return this->x_.get ();
}

void coordinate::
x (const x_type& x)
{
  this->x_.set (x);
}

const coordinate::y_type& coordinate::
y () const
{
  return this->y_.get ();
}

coordinate::y_type& coordinate::
y ()
{
  return this->y_.get ();
}

void coordinate::
y (const y_type& x)
{
  this->y_.set (x);
}

const coordinate::z_type& coordinate::
z () const
{
  return this->z_.get ();
}

coordinate::z_type& coordinate::
z ()
{
  return this->z_.get ();
}

void coordinate::
z (const z_type& x)
{
  this->z_.set (x);
}


// dimensions
//

const dimensions::x_type& dimensions::
x () const
{
  return this->x_.get ();
}

dimensions::x_type& dimensions::
x ()
{
  return this->x_.get ();
}

void dimensions::
x (const x_type& x)
{
  this->x_.set (x);
}

const dimensions::y_type& dimensions::
y () const
{
  return this->y_.get ();
}

dimensions::y_type& dimensions::
y ()
{
  return this->y_.get ();
}

void dimensions::
y (const y_type& x)
{
  this->y_.set (x);
}

const dimensions::z_type& dimensions::
z () const
{
  return this->z_.get ();
}

dimensions::z_type& dimensions::
z ()
{
  return this->z_.get ();
}

void dimensions::
z (const z_type& x)
{
  this->z_.set (x);
}


// additional_force
//

const additional_force::particle_coordinates_sequence& additional_force::
particle_coordinates () const
{
  return this->particle_coordinates_;
}

additional_force::particle_coordinates_sequence& additional_force::
particle_coordinates ()
{
  return this->particle_coordinates_;
}

void additional_force::
particle_coordinates (const particle_coordinates_sequence& s)
{
  this->particle_coordinates_ = s;
}

const additional_force::fzup_type& additional_force::
fzup () const
{
  return this->fzup_.get ();
}

additional_force::fzup_type& additional_force::
fzup ()
{
  return this->fzup_.get ();
}

void additional_force::
fzup (const fzup_type& x)
{
  this->fzup_.set (x);
}

const additional_force::time_limit_type& additional_force::
time_limit () const
{
  return this->time_limit_.get ();
}

additional_force::time_limit_type& additional_force::
time_limit ()
{
  return this->time_limit_.get ();
}

void additional_force::
time_limit (const time_limit_type& x)
{
  this->time_limit_.set (x);
}


// membrane
//

const membrane::k_type& membrane::
k () const
{
  return this->k_.get ();
}

membrane::k_type& membrane::
k ()
{
  return this->k_.get ();
}

void membrane::
k (const k_type& x)
{
  this->k_.set (x);
}

const membrane::r_0_type& membrane::
r_0 () const
{
  return this->r_0_.get ();
}

membrane::r_0_type& membrane::
r_0 ()
{
  return this->r_0_.get ();
}

void membrane::
r_0 (const r_0_type& x)
{
  this->r_0_.set (x);
}


// position
//

const position::x_type& position::
x () const
{
  return this->x_.get ();
}

position::x_type& position::
x ()
{
  return this->x_.get ();
}

void position::
x (const x_type& x)
{
  this->x_.set (x);
}

const position::y_type& position::
y () const
{
  return this->y_.get ();
}

position::y_type& position::
y ()
{
  return this->y_.get ();
}

void position::
y (const y_type& x)
{
  this->y_.set (x);
}

const position::z_type& position::
z () const
{
  return this->z_.get ();
}

position::z_type& position::
z ()
{
  return this->z_.get ();
}

void position::
z (const z_type& x)
{
  this->z_.set (x);
}


// velocity
//

const velocity::x_type& velocity::
x () const
{
  return this->x_.get ();
}

velocity::x_type& velocity::
x ()
{
  return this->x_.get ();
}

void velocity::
x (const x_type& x)
{
  this->x_.set (x);
}

const velocity::y_type& velocity::
y () const
{
  return this->y_.get ();
}

velocity::y_type& velocity::
y ()
{
  return this->y_.get ();
}

void velocity::
y (const y_type& x)
{
  this->y_.set (x);
}

const velocity::z_type& velocity::
z () const
{
  return this->z_.get ();
}

velocity::z_type& velocity::
z ()
{
  return this->z_.get ();
}

void velocity::
z (const z_type& x)
{
  this->z_.set (x);
}


// particle_coordinates
//

const particle_coordinates::x_type& particle_coordinates::
x () const
{
  return this->x_.get ();
}

particle_coordinates::x_type& particle_coordinates::
x ()
{
  return this->x_.get ();
}

void particle_coordinates::
x (const x_type& x)
{
  this->x_.set (x);
}

const particle_coordinates::y_type& particle_coordinates::
y () const
{
  return this->y_.get ();
}

particle_coordinates::y_type& particle_coordinates::
y ()
{
  return this->y_.get ();
}

void particle_coordinates::
y (const y_type& x)
{
  this->y_.set (x);
}

const particle_coordinates::z_type& particle_coordinates::
z () const
{
  return this->z_.get ();
}

particle_coordinates::z_type& particle_coordinates::
z ()
{
  return this->z_.get ();
}

void particle_coordinates::
z (const z_type& x)
{
  this->z_.set (x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// boundary_condition_type
//

boundary_condition_type::
boundary_condition_type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_boundary_condition_type_convert ();
}

boundary_condition_type::
boundary_condition_type (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_boundary_condition_type_convert ();
}

boundary_condition_type::
boundary_condition_type (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_boundary_condition_type_convert ();
}

boundary_condition_type* boundary_condition_type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class boundary_condition_type (*this, f, c);
}

boundary_condition_type::value boundary_condition_type::
_xsd_boundary_condition_type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_boundary_condition_type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_boundary_condition_type_indexes_,
                    _xsd_boundary_condition_type_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_boundary_condition_type_indexes_ + 3 || _xsd_boundary_condition_type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const boundary_condition_type::
_xsd_boundary_condition_type_literals_[3] =
{
  "Outflow",
  "Reflecting",
  "Periodic"
};

const boundary_condition_type::value boundary_condition_type::
_xsd_boundary_condition_type_indexes_[3] =
{
  ::boundary_condition_type::Outflow,
  ::boundary_condition_type::Periodic,
  ::boundary_condition_type::Reflecting
};

// MolSim
//

MolSim::
MolSim (const simulation_parameters_type& simulation_parameters)
: ::xml_schema::type (),
  simulation_parameters_ (simulation_parameters, this),
  thermostats_ (this),
  boundary_conditions_ (this),
  discs_ (this),
  cuboids_ (this),
  particles_ (this)
{
}

MolSim::
MolSim (::std::unique_ptr< simulation_parameters_type > simulation_parameters)
: ::xml_schema::type (),
  simulation_parameters_ (std::move (simulation_parameters), this),
  thermostats_ (this),
  boundary_conditions_ (this),
  discs_ (this),
  cuboids_ (this),
  particles_ (this)
{
}

MolSim::
MolSim (const MolSim& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  simulation_parameters_ (x.simulation_parameters_, f, this),
  thermostats_ (x.thermostats_, f, this),
  boundary_conditions_ (x.boundary_conditions_, f, this),
  discs_ (x.discs_, f, this),
  cuboids_ (x.cuboids_, f, this),
  particles_ (x.particles_, f, this)
{
}

MolSim::
MolSim (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  simulation_parameters_ (this),
  thermostats_ (this),
  boundary_conditions_ (this),
  discs_ (this),
  cuboids_ (this),
  particles_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void MolSim::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // simulation_parameters
    //
    if (n.name () == "simulation_parameters" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< simulation_parameters_type > r (
        simulation_parameters_traits::create (i, f, this));

      if (!simulation_parameters_.present ())
      {
        this->simulation_parameters_.set (::std::move (r));
        continue;
      }
    }

    // thermostats
    //
    if (n.name () == "thermostats" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< thermostats_type > r (
        thermostats_traits::create (i, f, this));

      if (!this->thermostats_)
      {
        this->thermostats_.set (::std::move (r));
        continue;
      }
    }

    // boundary_conditions
    //
    if (n.name () == "boundary_conditions" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< boundary_conditions_type > r (
        boundary_conditions_traits::create (i, f, this));

      if (!this->boundary_conditions_)
      {
        this->boundary_conditions_.set (::std::move (r));
        continue;
      }
    }

    // discs
    //
    if (n.name () == "discs" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< discs_type > r (
        discs_traits::create (i, f, this));

      if (!this->discs_)
      {
        this->discs_.set (::std::move (r));
        continue;
      }
    }

    // cuboids
    //
    if (n.name () == "cuboids" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< cuboids_type > r (
        cuboids_traits::create (i, f, this));

      if (!this->cuboids_)
      {
        this->cuboids_.set (::std::move (r));
        continue;
      }
    }

    // particles
    //
    if (n.name () == "particles" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< particles_type > r (
        particles_traits::create (i, f, this));

      if (!this->particles_)
      {
        this->particles_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!simulation_parameters_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "simulation_parameters",
      "");
  }
}

MolSim* MolSim::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MolSim (*this, f, c);
}

MolSim& MolSim::
operator= (const MolSim& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->simulation_parameters_ = x.simulation_parameters_;
    this->thermostats_ = x.thermostats_;
    this->boundary_conditions_ = x.boundary_conditions_;
    this->discs_ = x.discs_;
    this->cuboids_ = x.cuboids_;
    this->particles_ = x.particles_;
  }

  return *this;
}

MolSim::
~MolSim ()
{
}

// simulation_parameters
//

simulation_parameters::
simulation_parameters (const end_time_type& end_time,
                       const delta_time_type& delta_time,
                       const output_basename_type& output_basename,
                       const write_frequency_type& write_frequency,
                       const r_cutoff_radius_type& r_cutoff_radius,
                       const enable_brownian_type& enable_brownian)
: ::xml_schema::type (),
  end_time_ (end_time, this),
  delta_time_ (delta_time, this),
  output_basename_ (output_basename, this),
  write_frequency_ (write_frequency, this),
  r_cutoff_radius_ (r_cutoff_radius, this),
  gravity_ (this),
  zgravity_ (this),
  enable_brownian_ (enable_brownian, this),
  domain_size_ (this)
{
}

simulation_parameters::
simulation_parameters (const simulation_parameters& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  end_time_ (x.end_time_, f, this),
  delta_time_ (x.delta_time_, f, this),
  output_basename_ (x.output_basename_, f, this),
  write_frequency_ (x.write_frequency_, f, this),
  r_cutoff_radius_ (x.r_cutoff_radius_, f, this),
  gravity_ (x.gravity_, f, this),
  zgravity_ (x.zgravity_, f, this),
  enable_brownian_ (x.enable_brownian_, f, this),
  domain_size_ (x.domain_size_, f, this)
{
}

simulation_parameters::
simulation_parameters (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  end_time_ (this),
  delta_time_ (this),
  output_basename_ (this),
  write_frequency_ (this),
  r_cutoff_radius_ (this),
  gravity_ (this),
  zgravity_ (this),
  enable_brownian_ (this),
  domain_size_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void simulation_parameters::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // end_time
    //
    if (n.name () == "end_time" && n.namespace_ ().empty ())
    {
      if (!end_time_.present ())
      {
        this->end_time_.set (end_time_traits::create (i, f, this));
        continue;
      }
    }

    // delta_time
    //
    if (n.name () == "delta_time" && n.namespace_ ().empty ())
    {
      if (!delta_time_.present ())
      {
        this->delta_time_.set (delta_time_traits::create (i, f, this));
        continue;
      }
    }

    // output_basename
    //
    if (n.name () == "output_basename" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< output_basename_type > r (
        output_basename_traits::create (i, f, this));

      if (!output_basename_.present ())
      {
        this->output_basename_.set (::std::move (r));
        continue;
      }
    }

    // write_frequency
    //
    if (n.name () == "write_frequency" && n.namespace_ ().empty ())
    {
      if (!write_frequency_.present ())
      {
        this->write_frequency_.set (write_frequency_traits::create (i, f, this));
        continue;
      }
    }

    // r_cutoff_radius
    //
    if (n.name () == "r_cutoff_radius" && n.namespace_ ().empty ())
    {
      if (!r_cutoff_radius_.present ())
      {
        this->r_cutoff_radius_.set (r_cutoff_radius_traits::create (i, f, this));
        continue;
      }
    }

    // gravity
    //
    if (n.name () == "gravity" && n.namespace_ ().empty ())
    {
      if (!this->gravity_)
      {
        this->gravity_.set (gravity_traits::create (i, f, this));
        continue;
      }
    }

    // zgravity
    //
    if (n.name () == "zgravity" && n.namespace_ ().empty ())
    {
      if (!this->zgravity_)
      {
        this->zgravity_.set (zgravity_traits::create (i, f, this));
        continue;
      }
    }

    // enable_brownian
    //
    if (n.name () == "enable_brownian" && n.namespace_ ().empty ())
    {
      if (!enable_brownian_.present ())
      {
        this->enable_brownian_.set (enable_brownian_traits::create (i, f, this));
        continue;
      }
    }

    // domain_size
    //
    if (n.name () == "domain_size" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< domain_size_type > r (
        domain_size_traits::create (i, f, this));

      if (!this->domain_size_)
      {
        this->domain_size_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!end_time_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "end_time",
      "");
  }

  if (!delta_time_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "delta_time",
      "");
  }

  if (!output_basename_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "output_basename",
      "");
  }

  if (!write_frequency_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "write_frequency",
      "");
  }

  if (!r_cutoff_radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "r_cutoff_radius",
      "");
  }

  if (!enable_brownian_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "enable_brownian",
      "");
  }
}

simulation_parameters* simulation_parameters::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class simulation_parameters (*this, f, c);
}

simulation_parameters& simulation_parameters::
operator= (const simulation_parameters& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->end_time_ = x.end_time_;
    this->delta_time_ = x.delta_time_;
    this->output_basename_ = x.output_basename_;
    this->write_frequency_ = x.write_frequency_;
    this->r_cutoff_radius_ = x.r_cutoff_radius_;
    this->gravity_ = x.gravity_;
    this->zgravity_ = x.zgravity_;
    this->enable_brownian_ = x.enable_brownian_;
    this->domain_size_ = x.domain_size_;
  }

  return *this;
}

simulation_parameters::
~simulation_parameters ()
{
}

// thermostats
//

thermostats::
thermostats (const initial_temp_type& initial_temp,
             const target_temp_type& target_temp,
             const delta_temp_type& delta_temp,
             const is_gradual_type& is_gradual,
             const n_thermostats_type& n_thermostats)
: ::xml_schema::type (),
  initial_temp_ (initial_temp, this),
  target_temp_ (target_temp, this),
  delta_temp_ (delta_temp, this),
  is_gradual_ (is_gradual, this),
  n_thermostats_ (n_thermostats, this)
{
}

thermostats::
thermostats (const thermostats& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  initial_temp_ (x.initial_temp_, f, this),
  target_temp_ (x.target_temp_, f, this),
  delta_temp_ (x.delta_temp_, f, this),
  is_gradual_ (x.is_gradual_, f, this),
  n_thermostats_ (x.n_thermostats_, f, this)
{
}

thermostats::
thermostats (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  initial_temp_ (this),
  target_temp_ (this),
  delta_temp_ (this),
  is_gradual_ (this),
  n_thermostats_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void thermostats::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // initial_temp
    //
    if (n.name () == "initial_temp" && n.namespace_ ().empty ())
    {
      if (!initial_temp_.present ())
      {
        this->initial_temp_.set (initial_temp_traits::create (i, f, this));
        continue;
      }
    }

    // target_temp
    //
    if (n.name () == "target_temp" && n.namespace_ ().empty ())
    {
      if (!target_temp_.present ())
      {
        this->target_temp_.set (target_temp_traits::create (i, f, this));
        continue;
      }
    }

    // delta_temp
    //
    if (n.name () == "delta_temp" && n.namespace_ ().empty ())
    {
      if (!delta_temp_.present ())
      {
        this->delta_temp_.set (delta_temp_traits::create (i, f, this));
        continue;
      }
    }

    // is_gradual
    //
    if (n.name () == "is_gradual" && n.namespace_ ().empty ())
    {
      if (!is_gradual_.present ())
      {
        this->is_gradual_.set (is_gradual_traits::create (i, f, this));
        continue;
      }
    }

    // n_thermostats
    //
    if (n.name () == "n_thermostats" && n.namespace_ ().empty ())
    {
      if (!n_thermostats_.present ())
      {
        this->n_thermostats_.set (n_thermostats_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!initial_temp_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "initial_temp",
      "");
  }

  if (!target_temp_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "target_temp",
      "");
  }

  if (!delta_temp_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "delta_temp",
      "");
  }

  if (!is_gradual_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "is_gradual",
      "");
  }

  if (!n_thermostats_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "n_thermostats",
      "");
  }
}

thermostats* thermostats::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class thermostats (*this, f, c);
}

thermostats& thermostats::
operator= (const thermostats& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->initial_temp_ = x.initial_temp_;
    this->target_temp_ = x.target_temp_;
    this->delta_temp_ = x.delta_temp_;
    this->is_gradual_ = x.is_gradual_;
    this->n_thermostats_ = x.n_thermostats_;
  }

  return *this;
}

thermostats::
~thermostats ()
{
}

// boundary_conditions
//

boundary_conditions::
boundary_conditions (const left_type& left,
                     const right_type& right,
                     const top_type& top,
                     const bottom_type& bottom)
: ::xml_schema::type (),
  left_ (left, this),
  right_ (right, this),
  top_ (top, this),
  bottom_ (bottom, this),
  front_ (this),
  back_ (this)
{
}

boundary_conditions::
boundary_conditions (const boundary_conditions& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  left_ (x.left_, f, this),
  right_ (x.right_, f, this),
  top_ (x.top_, f, this),
  bottom_ (x.bottom_, f, this),
  front_ (x.front_, f, this),
  back_ (x.back_, f, this)
{
}

boundary_conditions::
boundary_conditions (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  left_ (this),
  right_ (this),
  top_ (this),
  bottom_ (this),
  front_ (this),
  back_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void boundary_conditions::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // left
    //
    if (n.name () == "left" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< left_type > r (
        left_traits::create (i, f, this));

      if (!left_.present ())
      {
        this->left_.set (::std::move (r));
        continue;
      }
    }

    // right
    //
    if (n.name () == "right" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< right_type > r (
        right_traits::create (i, f, this));

      if (!right_.present ())
      {
        this->right_.set (::std::move (r));
        continue;
      }
    }

    // top
    //
    if (n.name () == "top" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< top_type > r (
        top_traits::create (i, f, this));

      if (!top_.present ())
      {
        this->top_.set (::std::move (r));
        continue;
      }
    }

    // bottom
    //
    if (n.name () == "bottom" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< bottom_type > r (
        bottom_traits::create (i, f, this));

      if (!bottom_.present ())
      {
        this->bottom_.set (::std::move (r));
        continue;
      }
    }

    // front
    //
    if (n.name () == "front" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< front_type > r (
        front_traits::create (i, f, this));

      if (!this->front_)
      {
        this->front_.set (::std::move (r));
        continue;
      }
    }

    // back
    //
    if (n.name () == "back" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< back_type > r (
        back_traits::create (i, f, this));

      if (!this->back_)
      {
        this->back_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!left_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "left",
      "");
  }

  if (!right_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "right",
      "");
  }

  if (!top_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "top",
      "");
  }

  if (!bottom_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "bottom",
      "");
  }
}

boundary_conditions* boundary_conditions::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class boundary_conditions (*this, f, c);
}

boundary_conditions& boundary_conditions::
operator= (const boundary_conditions& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->left_ = x.left_;
    this->right_ = x.right_;
    this->top_ = x.top_;
    this->bottom_ = x.bottom_;
    this->front_ = x.front_;
    this->back_ = x.back_;
  }

  return *this;
}

boundary_conditions::
~boundary_conditions ()
{
}

// discs
//

discs::
discs ()
: ::xml_schema::type (),
  disc_ (this)
{
}

discs::
discs (const discs& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  disc_ (x.disc_, f, this)
{
}

discs::
discs (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  disc_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void discs::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // disc
    //
    if (n.name () == "disc" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< disc_type > r (
        disc_traits::create (i, f, this));

      this->disc_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

discs* discs::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class discs (*this, f, c);
}

discs& discs::
operator= (const discs& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->disc_ = x.disc_;
  }

  return *this;
}

discs::
~discs ()
{
}

// cuboids
//

cuboids::
cuboids ()
: ::xml_schema::type (),
  cuboid_ (this)
{
}

cuboids::
cuboids (const cuboids& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  cuboid_ (x.cuboid_, f, this)
{
}

cuboids::
cuboids (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  cuboid_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void cuboids::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // cuboid
    //
    if (n.name () == "cuboid" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< cuboid_type > r (
        cuboid_traits::create (i, f, this));

      this->cuboid_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

cuboids* cuboids::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class cuboids (*this, f, c);
}

cuboids& cuboids::
operator= (const cuboids& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->cuboid_ = x.cuboid_;
  }

  return *this;
}

cuboids::
~cuboids ()
{
}

// particles
//

particles::
particles ()
: ::xml_schema::type (),
  particle_ (this)
{
}

particles::
particles (const particles& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  particle_ (x.particle_, f, this)
{
}

particles::
particles (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  particle_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void particles::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // particle
    //
    if (n.name () == "particle" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< particle_type > r (
        particle_traits::create (i, f, this));

      this->particle_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

particles* particles::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class particles (*this, f, c);
}

particles& particles::
operator= (const particles& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->particle_ = x.particle_;
  }

  return *this;
}

particles::
~particles ()
{
}

// domain_size
//

domain_size::
domain_size (const x_type& x,
             const y_type& y,
             const z_type& z)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (z, this),
  lower_left_corner_ (this)
{
}

domain_size::
domain_size (const domain_size& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this),
  lower_left_corner_ (x.lower_left_corner_, f, this)
{
}

domain_size::
domain_size (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this),
  lower_left_corner_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void domain_size::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // x
    //
    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      if (!x_.present ())
      {
        this->x_.set (x_traits::create (i, f, this));
        continue;
      }
    }

    // y
    //
    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      if (!y_.present ())
      {
        this->y_.set (y_traits::create (i, f, this));
        continue;
      }
    }

    // z
    //
    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      if (!z_.present ())
      {
        this->z_.set (z_traits::create (i, f, this));
        continue;
      }
    }

    // lower-left-corner
    //
    if (n.name () == "lower-left-corner" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< lower_left_corner_type > r (
        lower_left_corner_traits::create (i, f, this));

      if (!this->lower_left_corner_)
      {
        this->lower_left_corner_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "y",
      "");
  }

  if (!z_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "z",
      "");
  }
}

domain_size* domain_size::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class domain_size (*this, f, c);
}

domain_size& domain_size::
operator= (const domain_size& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
    this->lower_left_corner_ = x.lower_left_corner_;
  }

  return *this;
}

domain_size::
~domain_size ()
{
}

// disc
//

disc::
disc (const center_type& center,
      const initial_velocity_type& initial_velocity,
      const radius_type& radius,
      const mesh_width_type& mesh_width,
      const mass_type& mass,
      const epsilon_type& epsilon,
      const sigma_type& sigma)
: ::xml_schema::type (),
  center_ (center, this),
  initial_velocity_ (initial_velocity, this),
  radius_ (radius, this),
  mesh_width_ (mesh_width, this),
  mass_ (mass, this),
  epsilon_ (epsilon, this),
  sigma_ (sigma, this)
{
}

disc::
disc (::std::unique_ptr< center_type > center,
      ::std::unique_ptr< initial_velocity_type > initial_velocity,
      const radius_type& radius,
      const mesh_width_type& mesh_width,
      const mass_type& mass,
      const epsilon_type& epsilon,
      const sigma_type& sigma)
: ::xml_schema::type (),
  center_ (std::move (center), this),
  initial_velocity_ (std::move (initial_velocity), this),
  radius_ (radius, this),
  mesh_width_ (mesh_width, this),
  mass_ (mass, this),
  epsilon_ (epsilon, this),
  sigma_ (sigma, this)
{
}

disc::
disc (const disc& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  center_ (x.center_, f, this),
  initial_velocity_ (x.initial_velocity_, f, this),
  radius_ (x.radius_, f, this),
  mesh_width_ (x.mesh_width_, f, this),
  mass_ (x.mass_, f, this),
  epsilon_ (x.epsilon_, f, this),
  sigma_ (x.sigma_, f, this)
{
}

disc::
disc (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  center_ (this),
  initial_velocity_ (this),
  radius_ (this),
  mesh_width_ (this),
  mass_ (this),
  epsilon_ (this),
  sigma_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void disc::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // center
    //
    if (n.name () == "center" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< center_type > r (
        center_traits::create (i, f, this));

      if (!center_.present ())
      {
        this->center_.set (::std::move (r));
        continue;
      }
    }

    // initial_velocity
    //
    if (n.name () == "initial_velocity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< initial_velocity_type > r (
        initial_velocity_traits::create (i, f, this));

      if (!initial_velocity_.present ())
      {
        this->initial_velocity_.set (::std::move (r));
        continue;
      }
    }

    // radius
    //
    if (n.name () == "radius" && n.namespace_ ().empty ())
    {
      if (!radius_.present ())
      {
        this->radius_.set (radius_traits::create (i, f, this));
        continue;
      }
    }

    // mesh_width
    //
    if (n.name () == "mesh_width" && n.namespace_ ().empty ())
    {
      if (!mesh_width_.present ())
      {
        this->mesh_width_.set (mesh_width_traits::create (i, f, this));
        continue;
      }
    }

    // mass
    //
    if (n.name () == "mass" && n.namespace_ ().empty ())
    {
      if (!mass_.present ())
      {
        this->mass_.set (mass_traits::create (i, f, this));
        continue;
      }
    }

    // epsilon
    //
    if (n.name () == "epsilon" && n.namespace_ ().empty ())
    {
      if (!epsilon_.present ())
      {
        this->epsilon_.set (epsilon_traits::create (i, f, this));
        continue;
      }
    }

    // sigma
    //
    if (n.name () == "sigma" && n.namespace_ ().empty ())
    {
      if (!sigma_.present ())
      {
        this->sigma_.set (sigma_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!center_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "center",
      "");
  }

  if (!initial_velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "initial_velocity",
      "");
  }

  if (!radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "radius",
      "");
  }

  if (!mesh_width_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mesh_width",
      "");
  }

  if (!mass_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mass",
      "");
  }

  if (!epsilon_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "epsilon",
      "");
  }

  if (!sigma_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "sigma",
      "");
  }
}

disc* disc::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class disc (*this, f, c);
}

disc& disc::
operator= (const disc& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->center_ = x.center_;
    this->initial_velocity_ = x.initial_velocity_;
    this->radius_ = x.radius_;
    this->mesh_width_ = x.mesh_width_;
    this->mass_ = x.mass_;
    this->epsilon_ = x.epsilon_;
    this->sigma_ = x.sigma_;
  }

  return *this;
}

disc::
~disc ()
{
}

// cuboid
//

cuboid::
cuboid (const coordinate_type& coordinate,
        const dimensions_type& dimensions,
        const mesh_width_type& mesh_width,
        const mass_type& mass,
        const epsilon_type& epsilon,
        const sigma_type& sigma,
        const initial_velocity_type& initial_velocity)
: ::xml_schema::type (),
  coordinate_ (coordinate, this),
  dimensions_ (dimensions, this),
  mesh_width_ (mesh_width, this),
  mass_ (mass, this),
  epsilon_ (epsilon, this),
  sigma_ (sigma, this),
  initial_velocity_ (initial_velocity, this),
  additional_force_ (this),
  membrane_ (this),
  fixed_ (this)
{
}

cuboid::
cuboid (::std::unique_ptr< coordinate_type > coordinate,
        ::std::unique_ptr< dimensions_type > dimensions,
        const mesh_width_type& mesh_width,
        const mass_type& mass,
        const epsilon_type& epsilon,
        const sigma_type& sigma,
        ::std::unique_ptr< initial_velocity_type > initial_velocity)
: ::xml_schema::type (),
  coordinate_ (std::move (coordinate), this),
  dimensions_ (std::move (dimensions), this),
  mesh_width_ (mesh_width, this),
  mass_ (mass, this),
  epsilon_ (epsilon, this),
  sigma_ (sigma, this),
  initial_velocity_ (std::move (initial_velocity), this),
  additional_force_ (this),
  membrane_ (this),
  fixed_ (this)
{
}

cuboid::
cuboid (const cuboid& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  coordinate_ (x.coordinate_, f, this),
  dimensions_ (x.dimensions_, f, this),
  mesh_width_ (x.mesh_width_, f, this),
  mass_ (x.mass_, f, this),
  epsilon_ (x.epsilon_, f, this),
  sigma_ (x.sigma_, f, this),
  initial_velocity_ (x.initial_velocity_, f, this),
  additional_force_ (x.additional_force_, f, this),
  membrane_ (x.membrane_, f, this),
  fixed_ (x.fixed_, f, this)
{
}

cuboid::
cuboid (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  coordinate_ (this),
  dimensions_ (this),
  mesh_width_ (this),
  mass_ (this),
  epsilon_ (this),
  sigma_ (this),
  initial_velocity_ (this),
  additional_force_ (this),
  membrane_ (this),
  fixed_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void cuboid::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // coordinate
    //
    if (n.name () == "coordinate" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< coordinate_type > r (
        coordinate_traits::create (i, f, this));

      if (!coordinate_.present ())
      {
        this->coordinate_.set (::std::move (r));
        continue;
      }
    }

    // dimensions
    //
    if (n.name () == "dimensions" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< dimensions_type > r (
        dimensions_traits::create (i, f, this));

      if (!dimensions_.present ())
      {
        this->dimensions_.set (::std::move (r));
        continue;
      }
    }

    // mesh_width
    //
    if (n.name () == "mesh_width" && n.namespace_ ().empty ())
    {
      if (!mesh_width_.present ())
      {
        this->mesh_width_.set (mesh_width_traits::create (i, f, this));
        continue;
      }
    }

    // mass
    //
    if (n.name () == "mass" && n.namespace_ ().empty ())
    {
      if (!mass_.present ())
      {
        this->mass_.set (mass_traits::create (i, f, this));
        continue;
      }
    }

    // epsilon
    //
    if (n.name () == "epsilon" && n.namespace_ ().empty ())
    {
      if (!epsilon_.present ())
      {
        this->epsilon_.set (epsilon_traits::create (i, f, this));
        continue;
      }
    }

    // sigma
    //
    if (n.name () == "sigma" && n.namespace_ ().empty ())
    {
      if (!sigma_.present ())
      {
        this->sigma_.set (sigma_traits::create (i, f, this));
        continue;
      }
    }

    // initial_velocity
    //
    if (n.name () == "initial_velocity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< initial_velocity_type > r (
        initial_velocity_traits::create (i, f, this));

      if (!initial_velocity_.present ())
      {
        this->initial_velocity_.set (::std::move (r));
        continue;
      }
    }

    // additional_force
    //
    if (n.name () == "additional_force" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< additional_force_type > r (
        additional_force_traits::create (i, f, this));

      if (!this->additional_force_)
      {
        this->additional_force_.set (::std::move (r));
        continue;
      }
    }

    // membrane
    //
    if (n.name () == "membrane" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< membrane_type > r (
        membrane_traits::create (i, f, this));

      if (!this->membrane_)
      {
        this->membrane_.set (::std::move (r));
        continue;
      }
    }

    // fixed
    //
    if (n.name () == "fixed" && n.namespace_ ().empty ())
    {
      if (!this->fixed_)
      {
        this->fixed_.set (fixed_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!coordinate_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "coordinate",
      "");
  }

  if (!dimensions_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "dimensions",
      "");
  }

  if (!mesh_width_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mesh_width",
      "");
  }

  if (!mass_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mass",
      "");
  }

  if (!epsilon_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "epsilon",
      "");
  }

  if (!sigma_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "sigma",
      "");
  }

  if (!initial_velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "initial_velocity",
      "");
  }
}

cuboid* cuboid::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class cuboid (*this, f, c);
}

cuboid& cuboid::
operator= (const cuboid& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->coordinate_ = x.coordinate_;
    this->dimensions_ = x.dimensions_;
    this->mesh_width_ = x.mesh_width_;
    this->mass_ = x.mass_;
    this->epsilon_ = x.epsilon_;
    this->sigma_ = x.sigma_;
    this->initial_velocity_ = x.initial_velocity_;
    this->additional_force_ = x.additional_force_;
    this->membrane_ = x.membrane_;
    this->fixed_ = x.fixed_;
  }

  return *this;
}

cuboid::
~cuboid ()
{
}

// particle
//

particle::
particle (const position_type& position,
          const velocity_type& velocity,
          const mass_type& mass)
: ::xml_schema::type (),
  position_ (position, this),
  velocity_ (velocity, this),
  mass_ (mass, this)
{
}

particle::
particle (::std::unique_ptr< position_type > position,
          ::std::unique_ptr< velocity_type > velocity,
          const mass_type& mass)
: ::xml_schema::type (),
  position_ (std::move (position), this),
  velocity_ (std::move (velocity), this),
  mass_ (mass, this)
{
}

particle::
particle (const particle& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  position_ (x.position_, f, this),
  velocity_ (x.velocity_, f, this),
  mass_ (x.mass_, f, this)
{
}

particle::
particle (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  position_ (this),
  velocity_ (this),
  mass_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void particle::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // position
    //
    if (n.name () == "position" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< position_type > r (
        position_traits::create (i, f, this));

      if (!position_.present ())
      {
        this->position_.set (::std::move (r));
        continue;
      }
    }

    // velocity
    //
    if (n.name () == "velocity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< velocity_type > r (
        velocity_traits::create (i, f, this));

      if (!velocity_.present ())
      {
        this->velocity_.set (::std::move (r));
        continue;
      }
    }

    // mass
    //
    if (n.name () == "mass" && n.namespace_ ().empty ())
    {
      if (!mass_.present ())
      {
        this->mass_.set (mass_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!position_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "position",
      "");
  }

  if (!velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocity",
      "");
  }

  if (!mass_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mass",
      "");
  }
}

particle* particle::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class particle (*this, f, c);
}

particle& particle::
operator= (const particle& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->position_ = x.position_;
    this->velocity_ = x.velocity_;
    this->mass_ = x.mass_;
  }

  return *this;
}

particle::
~particle ()
{
}

// lower_left_corner
//

lower_left_corner::
lower_left_corner (const x_type& x,
                   const y_type& y,
                   const z_type& z)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (z, this)
{
}

lower_left_corner::
lower_left_corner (const lower_left_corner& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

lower_left_corner::
lower_left_corner (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void lower_left_corner::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // x
    //
    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      if (!x_.present ())
      {
        this->x_.set (x_traits::create (i, f, this));
        continue;
      }
    }

    // y
    //
    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      if (!y_.present ())
      {
        this->y_.set (y_traits::create (i, f, this));
        continue;
      }
    }

    // z
    //
    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      if (!z_.present ())
      {
        this->z_.set (z_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "y",
      "");
  }

  if (!z_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "z",
      "");
  }
}

lower_left_corner* lower_left_corner::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class lower_left_corner (*this, f, c);
}

lower_left_corner& lower_left_corner::
operator= (const lower_left_corner& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

lower_left_corner::
~lower_left_corner ()
{
}

// center
//

center::
center (const x_type& x,
        const y_type& y,
        const z_type& z)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (z, this)
{
}

center::
center (const center& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

center::
center (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void center::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // x
    //
    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      if (!x_.present ())
      {
        this->x_.set (x_traits::create (i, f, this));
        continue;
      }
    }

    // y
    //
    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      if (!y_.present ())
      {
        this->y_.set (y_traits::create (i, f, this));
        continue;
      }
    }

    // z
    //
    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      if (!z_.present ())
      {
        this->z_.set (z_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "y",
      "");
  }

  if (!z_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "z",
      "");
  }
}

center* center::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class center (*this, f, c);
}

center& center::
operator= (const center& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

center::
~center ()
{
}

// initial_velocity
//

initial_velocity::
initial_velocity (const x_type& x,
                  const y_type& y,
                  const z_type& z)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (z, this)
{
}

initial_velocity::
initial_velocity (const initial_velocity& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

initial_velocity::
initial_velocity (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void initial_velocity::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // x
    //
    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      if (!x_.present ())
      {
        this->x_.set (x_traits::create (i, f, this));
        continue;
      }
    }

    // y
    //
    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      if (!y_.present ())
      {
        this->y_.set (y_traits::create (i, f, this));
        continue;
      }
    }

    // z
    //
    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      if (!z_.present ())
      {
        this->z_.set (z_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "y",
      "");
  }

  if (!z_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "z",
      "");
  }
}

initial_velocity* initial_velocity::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class initial_velocity (*this, f, c);
}

initial_velocity& initial_velocity::
operator= (const initial_velocity& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

initial_velocity::
~initial_velocity ()
{
}

// coordinate
//

coordinate::
coordinate (const x_type& x,
            const y_type& y,
            const z_type& z)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (z, this)
{
}

coordinate::
coordinate (const coordinate& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

coordinate::
coordinate (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void coordinate::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // x
    //
    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      if (!x_.present ())
      {
        this->x_.set (x_traits::create (i, f, this));
        continue;
      }
    }

    // y
    //
    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      if (!y_.present ())
      {
        this->y_.set (y_traits::create (i, f, this));
        continue;
      }
    }

    // z
    //
    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      if (!z_.present ())
      {
        this->z_.set (z_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "y",
      "");
  }

  if (!z_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "z",
      "");
  }
}

coordinate* coordinate::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class coordinate (*this, f, c);
}

coordinate& coordinate::
operator= (const coordinate& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

coordinate::
~coordinate ()
{
}

// dimensions
//

dimensions::
dimensions (const x_type& x,
            const y_type& y,
            const z_type& z)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (z, this)
{
}

dimensions::
dimensions (const dimensions& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

dimensions::
dimensions (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void dimensions::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // x
    //
    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      if (!x_.present ())
      {
        this->x_.set (x_traits::create (i, f, this));
        continue;
      }
    }

    // y
    //
    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      if (!y_.present ())
      {
        this->y_.set (y_traits::create (i, f, this));
        continue;
      }
    }

    // z
    //
    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      if (!z_.present ())
      {
        this->z_.set (z_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "y",
      "");
  }

  if (!z_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "z",
      "");
  }
}

dimensions* dimensions::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class dimensions (*this, f, c);
}

dimensions& dimensions::
operator= (const dimensions& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

dimensions::
~dimensions ()
{
}

// additional_force
//

additional_force::
additional_force (const fzup_type& fzup,
                  const time_limit_type& time_limit)
: ::xml_schema::type (),
  particle_coordinates_ (this),
  fzup_ (fzup, this),
  time_limit_ (time_limit, this)
{
}

additional_force::
additional_force (const additional_force& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  particle_coordinates_ (x.particle_coordinates_, f, this),
  fzup_ (x.fzup_, f, this),
  time_limit_ (x.time_limit_, f, this)
{
}

additional_force::
additional_force (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  particle_coordinates_ (this),
  fzup_ (this),
  time_limit_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void additional_force::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // particle_coordinates
    //
    if (n.name () == "particle_coordinates" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< particle_coordinates_type > r (
        particle_coordinates_traits::create (i, f, this));

      this->particle_coordinates_.push_back (::std::move (r));
      continue;
    }

    // fzup
    //
    if (n.name () == "fzup" && n.namespace_ ().empty ())
    {
      if (!fzup_.present ())
      {
        this->fzup_.set (fzup_traits::create (i, f, this));
        continue;
      }
    }

    // time_limit
    //
    if (n.name () == "time_limit" && n.namespace_ ().empty ())
    {
      if (!time_limit_.present ())
      {
        this->time_limit_.set (time_limit_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!fzup_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "fzup",
      "");
  }

  if (!time_limit_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "time_limit",
      "");
  }
}

additional_force* additional_force::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class additional_force (*this, f, c);
}

additional_force& additional_force::
operator= (const additional_force& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->particle_coordinates_ = x.particle_coordinates_;
    this->fzup_ = x.fzup_;
    this->time_limit_ = x.time_limit_;
  }

  return *this;
}

additional_force::
~additional_force ()
{
}

// membrane
//

membrane::
membrane (const k_type& k,
          const r_0_type& r_0)
: ::xml_schema::type (),
  k_ (k, this),
  r_0_ (r_0, this)
{
}

membrane::
membrane (const membrane& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  k_ (x.k_, f, this),
  r_0_ (x.r_0_, f, this)
{
}

membrane::
membrane (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  k_ (this),
  r_0_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void membrane::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // k
    //
    if (n.name () == "k" && n.namespace_ ().empty ())
    {
      if (!k_.present ())
      {
        this->k_.set (k_traits::create (i, f, this));
        continue;
      }
    }

    // r_0
    //
    if (n.name () == "r_0" && n.namespace_ ().empty ())
    {
      if (!r_0_.present ())
      {
        this->r_0_.set (r_0_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!k_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "k",
      "");
  }

  if (!r_0_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "r_0",
      "");
  }
}

membrane* membrane::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class membrane (*this, f, c);
}

membrane& membrane::
operator= (const membrane& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->k_ = x.k_;
    this->r_0_ = x.r_0_;
  }

  return *this;
}

membrane::
~membrane ()
{
}

// position
//

position::
position (const x_type& x,
          const y_type& y,
          const z_type& z)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (z, this)
{
}

position::
position (const position& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

position::
position (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void position::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // x
    //
    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      if (!x_.present ())
      {
        this->x_.set (x_traits::create (i, f, this));
        continue;
      }
    }

    // y
    //
    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      if (!y_.present ())
      {
        this->y_.set (y_traits::create (i, f, this));
        continue;
      }
    }

    // z
    //
    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      if (!z_.present ())
      {
        this->z_.set (z_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "y",
      "");
  }

  if (!z_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "z",
      "");
  }
}

position* position::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class position (*this, f, c);
}

position& position::
operator= (const position& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

position::
~position ()
{
}

// velocity
//

velocity::
velocity (const x_type& x,
          const y_type& y,
          const z_type& z)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (z, this)
{
}

velocity::
velocity (const velocity& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

velocity::
velocity (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void velocity::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // x
    //
    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      if (!x_.present ())
      {
        this->x_.set (x_traits::create (i, f, this));
        continue;
      }
    }

    // y
    //
    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      if (!y_.present ())
      {
        this->y_.set (y_traits::create (i, f, this));
        continue;
      }
    }

    // z
    //
    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      if (!z_.present ())
      {
        this->z_.set (z_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "y",
      "");
  }

  if (!z_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "z",
      "");
  }
}

velocity* velocity::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class velocity (*this, f, c);
}

velocity& velocity::
operator= (const velocity& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

velocity::
~velocity ()
{
}

// particle_coordinates
//

particle_coordinates::
particle_coordinates (const x_type& x,
                      const y_type& y,
                      const z_type& z)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (z, this)
{
}

particle_coordinates::
particle_coordinates (const particle_coordinates& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

particle_coordinates::
particle_coordinates (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void particle_coordinates::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // x
    //
    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      if (!x_.present ())
      {
        this->x_.set (x_traits::create (i, f, this));
        continue;
      }
    }

    // y
    //
    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      if (!y_.present ())
      {
        this->y_.set (y_traits::create (i, f, this));
        continue;
      }
    }

    // z
    //
    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      if (!z_.present ())
      {
        this->z_.set (z_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "y",
      "");
  }

  if (!z_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "z",
      "");
  }
}

particle_coordinates* particle_coordinates::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class particle_coordinates (*this, f, c);
}

particle_coordinates& particle_coordinates::
operator= (const particle_coordinates& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

particle_coordinates::
~particle_coordinates ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::unique_ptr< ::MolSim >
MolSim_ (const ::std::string& u,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::MolSim > (
    ::MolSim_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::MolSim >
MolSim_ (const ::std::string& u,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::MolSim > (
    ::MolSim_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::MolSim >
MolSim_ (const ::std::string& u,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::MolSim > (
    ::MolSim_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::MolSim >
MolSim_ (::std::istream& is,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::MolSim_ (isrc, f, p);
}

::std::unique_ptr< ::MolSim >
MolSim_ (::std::istream& is,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::MolSim_ (isrc, h, f, p);
}

::std::unique_ptr< ::MolSim >
MolSim_ (::std::istream& is,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::MolSim_ (isrc, h, f, p);
}

::std::unique_ptr< ::MolSim >
MolSim_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::MolSim_ (isrc, f, p);
}

::std::unique_ptr< ::MolSim >
MolSim_ (::std::istream& is,
         const ::std::string& sid,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::MolSim_ (isrc, h, f, p);
}

::std::unique_ptr< ::MolSim >
MolSim_ (::std::istream& is,
         const ::std::string& sid,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::MolSim_ (isrc, h, f, p);
}

::std::unique_ptr< ::MolSim >
MolSim_ (::xercesc::InputSource& i,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::MolSim > (
    ::MolSim_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::MolSim >
MolSim_ (::xercesc::InputSource& i,
         ::xml_schema::error_handler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::MolSim > (
    ::MolSim_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::MolSim >
MolSim_ (::xercesc::InputSource& i,
         ::xercesc::DOMErrorHandler& h,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::MolSim > (
    ::MolSim_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::MolSim >
MolSim_ (const ::xercesc::DOMDocument& doc,
         ::xml_schema::flags f,
         const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::unique_ptr< ::MolSim > (
      ::MolSim_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "MolSim" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::MolSim > r (
      ::xsd::cxx::tree::traits< ::MolSim, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "MolSim",
    "");
}

::std::unique_ptr< ::MolSim >
MolSim_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
         ::xml_schema::flags f,
         const ::xml_schema::properties&)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "MolSim" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::MolSim > r (
      ::xsd::cxx::tree::traits< ::MolSim, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "MolSim",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

